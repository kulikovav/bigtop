diff -uNr zookeeper-3.4.6/src/java/main/org/apache/zookeeper/server/quorum/Learner.java zookeeper-3.4.6-b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
--- zookeeper-3.4.6/src/java/main/org/apache/zookeeper/server/quorum/Learner.java	2014-02-20 14:14:09.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java	2016-12-26 10:45:28.000000000 +0400
@@ -197,6 +197,9 @@
         Vote current = self.getCurrentVote();
         for (QuorumServer s : self.getView().values()) {
             if (s.id == current.getId()) {
+                // Ensure we have the leader's correct IP address before
+                // attempting to connect.
+                s.recreateSocketAddresses();
                 addr = s.addr;
                 break;
             }
diff -uNr zookeeper-3.4.6/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java zookeeper-3.4.6-b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java
--- zookeeper-3.4.6/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java	2014-02-20 14:14:09.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java	2016-12-26 10:45:28.000000000 +0400
@@ -377,11 +377,22 @@
                 // detail.
                 LOG.warn("Cannot open channel to " + sid
                         + " at election address " + electionAddr, e);
+                // Resolve hostname for this server in case the
+                // underlying ip address has changed.
+                if (self.getView().containsKey(sid)) {
+                    self.getView().get(sid).recreateSocketAddresses();
+                }
                 throw e;
             } catch (IOException e) {
                 LOG.warn("Cannot open channel to " + sid
                         + " at election address " + electionAddr,
                         e);
+                // We can't really tell if the server is actually down or it failed
+                // to connect to the server because the underlying IP address
+                // changed. Resolve the hostname again just in case.
+                if (self.getView().containsKey(sid)) {
+                    self.getView().get(sid).recreateSocketAddresses();
+                }
             }
         } else {
             LOG.debug("There is a connection already for server " + sid);
diff -uNr zookeeper-3.4.6/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java.orig zookeeper-3.4.6-b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java.orig
--- zookeeper-3.4.6/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java.orig	1970-01-01 04:00:00.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java.orig	2014-02-20 14:14:09.000000000 +0400
@@ -0,0 +1,903 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketException;
+import java.nio.BufferUnderflowException;
+import java.nio.ByteBuffer;
+import java.nio.channels.UnresolvedAddressException;
+import java.util.Enumeration;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.TimeUnit;
+import java.util.NoSuchElementException;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.Date;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.zookeeper.server.ZooKeeperServer;
+
+/**
+ * This class implements a connection manager for leader election using TCP. It
+ * maintains one connection for every pair of servers. The tricky part is to
+ * guarantee that there is exactly one connection for every pair of servers that
+ * are operating correctly and that can communicate over the network.
+ * 
+ * If two servers try to start a connection concurrently, then the connection
+ * manager uses a very simple tie-breaking mechanism to decide which connection
+ * to drop based on the IP addressed of the two parties. 
+ * 
+ * For every peer, the manager maintains a queue of messages to send. If the
+ * connection to any particular peer drops, then the sender thread puts the
+ * message back on the list. As this implementation currently uses a queue
+ * implementation to maintain messages to send to another peer, we add the
+ * message to the tail of the queue, thus changing the order of messages.
+ * Although this is not a problem for the leader election, it could be a problem
+ * when consolidating peer communication. This is to be verified, though.
+ * 
+ */
+
+public class QuorumCnxManager {
+    private static final Logger LOG = LoggerFactory.getLogger(QuorumCnxManager.class);
+
+    /*
+     * Maximum capacity of thread queues
+     */
+    static final int RECV_CAPACITY = 100;
+    // Initialized to 1 to prevent sending
+    // stale notifications to peers
+    static final int SEND_CAPACITY = 1;
+
+    static final int PACKETMAXSIZE = 1024 * 512; 
+    /*
+     * Maximum number of attempts to connect to a peer
+     */
+
+    static final int MAX_CONNECTION_ATTEMPTS = 2;
+    
+    /*
+     * Negative counter for observer server ids.
+     */
+    
+    private long observerCounter = -1;
+    
+    /*
+     * Connection time out value in milliseconds 
+     */
+    
+    private int cnxTO = 5000;
+    
+    /*
+     * Local IP address
+     */
+    final QuorumPeer self;
+
+    /*
+     * Mapping from Peer to Thread number
+     */
+    final ConcurrentHashMap<Long, SendWorker> senderWorkerMap;
+    final ConcurrentHashMap<Long, ArrayBlockingQueue<ByteBuffer>> queueSendMap;
+    final ConcurrentHashMap<Long, ByteBuffer> lastMessageSent;
+
+    /*
+     * Reception queue
+     */
+    public final ArrayBlockingQueue<Message> recvQueue;
+    /*
+     * Object to synchronize access to recvQueue
+     */
+    private final Object recvQLock = new Object();
+
+    /*
+     * Shutdown flag
+     */
+
+    volatile boolean shutdown = false;
+
+    /*
+     * Listener thread
+     */
+    public final Listener listener;
+
+    /*
+     * Counter to count worker threads
+     */
+    private AtomicInteger threadCnt = new AtomicInteger(0);
+
+    static public class Message {
+        
+        Message(ByteBuffer buffer, long sid) {
+            this.buffer = buffer;
+            this.sid = sid;
+        }
+
+        ByteBuffer buffer;
+        long sid;
+    }
+
+    public QuorumCnxManager(QuorumPeer self) {
+        this.recvQueue = new ArrayBlockingQueue<Message>(RECV_CAPACITY);
+        this.queueSendMap = new ConcurrentHashMap<Long, ArrayBlockingQueue<ByteBuffer>>();
+        this.senderWorkerMap = new ConcurrentHashMap<Long, SendWorker>();
+        this.lastMessageSent = new ConcurrentHashMap<Long, ByteBuffer>();
+        
+        String cnxToValue = System.getProperty("zookeeper.cnxTimeout");
+        if(cnxToValue != null){
+            this.cnxTO = new Integer(cnxToValue); 
+        }
+        
+        this.self = self;
+
+        // Starts listener thread that waits for connection requests 
+        listener = new Listener();
+    }
+
+    /**
+     * Invokes initiateConnection for testing purposes
+     * 
+     * @param sid
+     */
+    public void testInitiateConnection(long sid) throws Exception {
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("Opening channel to server " + sid);
+        }
+        Socket sock = new Socket();
+        setSockOpts(sock);
+        sock.connect(self.getVotingView().get(sid).electionAddr, cnxTO);
+        initiateConnection(sock, sid);
+    }
+    
+    /**
+     * If this server has initiated the connection, then it gives up on the
+     * connection if it loses challenge. Otherwise, it keeps the connection.
+     */
+    public boolean initiateConnection(Socket sock, Long sid) {
+        DataOutputStream dout = null;
+        try {
+            // Sending id and challenge
+            dout = new DataOutputStream(sock.getOutputStream());
+            dout.writeLong(self.getId());
+            dout.flush();
+        } catch (IOException e) {
+            LOG.warn("Ignoring exception reading or writing challenge: ", e);
+            closeSocket(sock);
+            return false;
+        }
+        
+        // If lost the challenge, then drop the new connection
+        if (sid > self.getId()) {
+            LOG.info("Have smaller server identifier, so dropping the " +
+                     "connection: (" + sid + ", " + self.getId() + ")");
+            closeSocket(sock);
+            // Otherwise proceed with the connection
+        } else {
+            SendWorker sw = new SendWorker(sock, sid);
+            RecvWorker rw = new RecvWorker(sock, sid, sw);
+            sw.setRecv(rw);
+
+            SendWorker vsw = senderWorkerMap.get(sid);
+            
+            if(vsw != null)
+                vsw.finish();
+            
+            senderWorkerMap.put(sid, sw);
+            if (!queueSendMap.containsKey(sid)) {
+                queueSendMap.put(sid, new ArrayBlockingQueue<ByteBuffer>(
+                        SEND_CAPACITY));
+            }
+            
+            sw.start();
+            rw.start();
+            
+            return true;    
+            
+        }
+        return false;
+    }
+
+    
+    
+    /**
+     * If this server receives a connection request, then it gives up on the new
+     * connection if it wins. Notice that it checks whether it has a connection
+     * to this server already or not. If it does, then it sends the smallest
+     * possible long value to lose the challenge.
+     * 
+     */
+    public boolean receiveConnection(Socket sock) {
+        Long sid = null;
+        
+        try {
+            // Read server id
+            DataInputStream din = new DataInputStream(sock.getInputStream());
+            sid = din.readLong();
+            if (sid < 0) { // this is not a server id but a protocol version (see ZOOKEEPER-1633)
+                sid = din.readLong();
+                // next comes the #bytes in the remainder of the message
+                int num_remaining_bytes = din.readInt();
+                byte[] b = new byte[num_remaining_bytes];
+                // remove the remainder of the message from din
+                int num_read = din.read(b);
+                if (num_read != num_remaining_bytes) {
+                    LOG.error("Read only " + num_read + " bytes out of " + num_remaining_bytes + " sent by server " + sid);
+                }
+            }
+            if (sid == QuorumPeer.OBSERVER_ID) {
+                /*
+                 * Choose identifier at random. We need a value to identify
+                 * the connection.
+                 */
+                
+                sid = observerCounter--;
+                LOG.info("Setting arbitrary identifier to observer: " + sid);
+            }
+        } catch (IOException e) {
+            closeSocket(sock);
+            LOG.warn("Exception reading or writing challenge: " + e.toString());
+            return false;
+        }
+        
+        //If wins the challenge, then close the new connection.
+        if (sid < self.getId()) {
+            /*
+             * This replica might still believe that the connection to sid is
+             * up, so we have to shut down the workers before trying to open a
+             * new connection.
+             */
+            SendWorker sw = senderWorkerMap.get(sid);
+            if (sw != null) {
+                sw.finish();
+            }
+
+            /*
+             * Now we start a new connection
+             */
+            LOG.debug("Create new connection to server: " + sid);
+            closeSocket(sock);
+            connectOne(sid);
+
+            // Otherwise start worker threads to receive data.
+        } else {
+            SendWorker sw = new SendWorker(sock, sid);
+            RecvWorker rw = new RecvWorker(sock, sid, sw);
+            sw.setRecv(rw);
+
+            SendWorker vsw = senderWorkerMap.get(sid);
+            
+            if(vsw != null)
+                vsw.finish();
+            
+            senderWorkerMap.put(sid, sw);
+            
+            if (!queueSendMap.containsKey(sid)) {
+                queueSendMap.put(sid, new ArrayBlockingQueue<ByteBuffer>(
+                        SEND_CAPACITY));
+            }
+            
+            sw.start();
+            rw.start();
+            
+            return true;    
+        }
+        return false;
+    }
+
+    /**
+     * Processes invoke this message to queue a message to send. Currently, 
+     * only leader election uses it.
+     */
+    public void toSend(Long sid, ByteBuffer b) {
+        /*
+         * If sending message to myself, then simply enqueue it (loopback).
+         */
+        if (self.getId() == sid) {
+             b.position(0);
+             addToRecvQueue(new Message(b.duplicate(), sid));
+            /*
+             * Otherwise send to the corresponding thread to send.
+             */
+        } else {
+             /*
+              * Start a new connection if doesn't have one already.
+              */
+             if (!queueSendMap.containsKey(sid)) {
+                 ArrayBlockingQueue<ByteBuffer> bq = new ArrayBlockingQueue<ByteBuffer>(
+                         SEND_CAPACITY);
+                 queueSendMap.put(sid, bq);
+                 addToSendQueue(bq, b);
+
+             } else {
+                 ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);
+                 if(bq != null){
+                     addToSendQueue(bq, b);
+                 } else {
+                     LOG.error("No queue for server " + sid);
+                 }
+             }
+             connectOne(sid);
+                
+        }
+    }
+    
+    /**
+     * Try to establish a connection to server with id sid.
+     * 
+     *  @param sid  server id
+     */
+    
+    synchronized void connectOne(long sid){
+        if (senderWorkerMap.get(sid) == null){
+            InetSocketAddress electionAddr;
+            if (self.quorumPeers.containsKey(sid)) {
+                electionAddr = self.quorumPeers.get(sid).electionAddr;
+            } else {
+                LOG.warn("Invalid server id: " + sid);
+                return;
+            }
+            try {
+
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug("Opening channel to server " + sid);
+                }
+                Socket sock = new Socket();
+                setSockOpts(sock);
+                sock.connect(self.getView().get(sid).electionAddr, cnxTO);
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug("Connected to server " + sid);
+                }
+                initiateConnection(sock, sid);
+            } catch (UnresolvedAddressException e) {
+                // Sun doesn't include the address that causes this
+                // exception to be thrown, also UAE cannot be wrapped cleanly
+                // so we log the exception in order to capture this critical
+                // detail.
+                LOG.warn("Cannot open channel to " + sid
+                        + " at election address " + electionAddr, e);
+                throw e;
+            } catch (IOException e) {
+                LOG.warn("Cannot open channel to " + sid
+                        + " at election address " + electionAddr,
+                        e);
+            }
+        } else {
+            LOG.debug("There is a connection already for server " + sid);
+        }
+    }
+    
+    
+    /**
+     * Try to establish a connection with each server if one
+     * doesn't exist.
+     */
+    
+    public void connectAll(){
+        long sid;
+        for(Enumeration<Long> en = queueSendMap.keys();
+            en.hasMoreElements();){
+            sid = en.nextElement();
+            connectOne(sid);
+        }      
+    }
+    
+
+    /**
+     * Check if all queues are empty, indicating that all messages have been delivered.
+     */
+    boolean haveDelivered() {
+        for (ArrayBlockingQueue<ByteBuffer> queue : queueSendMap.values()) {
+            LOG.debug("Queue size: " + queue.size());
+            if (queue.size() == 0) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Flag that it is time to wrap up all activities and interrupt the listener.
+     */
+    public void halt() {
+        shutdown = true;
+        LOG.debug("Halting listener");
+        listener.halt();
+        
+        softHalt();
+    }
+   
+    /**
+     * A soft halt simply finishes workers.
+     */
+    public void softHalt() {
+        for (SendWorker sw : senderWorkerMap.values()) {
+            LOG.debug("Halting sender: " + sw);
+            sw.finish();
+        }
+    }
+
+    /**
+     * Helper method to set socket options.
+     * 
+     * @param sock
+     *            Reference to socket
+     */
+    private void setSockOpts(Socket sock) throws SocketException {
+        sock.setTcpNoDelay(true);
+        sock.setSoTimeout(self.tickTime * self.syncLimit);
+    }
+
+    /**
+     * Helper method to close a socket.
+     * 
+     * @param sock
+     *            Reference to socket
+     */
+    private void closeSocket(Socket sock) {
+        try {
+            sock.close();
+        } catch (IOException ie) {
+            LOG.error("Exception while closing", ie);
+        }
+    }
+
+    /**
+     * Return number of worker threads
+     */
+    public long getThreadCount() {
+        return threadCnt.get();
+    }
+    /**
+     * Return reference to QuorumPeer
+     */
+    public QuorumPeer getQuorumPeer() {
+        return self;
+    }
+
+    /**
+     * Thread to listen on some port
+     */
+    public class Listener extends Thread {
+
+        volatile ServerSocket ss = null;
+
+        /**
+         * Sleeps on accept().
+         */
+        @Override
+        public void run() {
+            int numRetries = 0;
+            InetSocketAddress addr;
+            while((!shutdown) && (numRetries < 3)){
+                try {
+                    ss = new ServerSocket();
+                    ss.setReuseAddress(true);
+                    if (self.getQuorumListenOnAllIPs()) {
+                        int port = self.quorumPeers.get(self.getId()).electionAddr.getPort();
+                        addr = new InetSocketAddress(port);
+                    } else {
+                        addr = self.quorumPeers.get(self.getId()).electionAddr;
+                    }
+                    LOG.info("My election bind port: " + addr.toString());
+                    setName(self.quorumPeers.get(self.getId()).electionAddr
+                            .toString());
+                    ss.bind(addr);
+                    while (!shutdown) {
+                        Socket client = ss.accept();
+                        setSockOpts(client);
+                        LOG.info("Received connection request "
+                                + client.getRemoteSocketAddress());
+                        receiveConnection(client);
+                        numRetries = 0;
+                    }
+                } catch (IOException e) {
+                    LOG.error("Exception while listening", e);
+                    numRetries++;
+                    try {
+                        ss.close();
+                        Thread.sleep(1000);
+                    } catch (IOException ie) {
+                        LOG.error("Error closing server socket", ie);
+                    } catch (InterruptedException ie) {
+                        LOG.error("Interrupted while sleeping. " +
+                                  "Ignoring exception", ie);
+                    }
+                }
+            }
+            LOG.info("Leaving listener");
+            if (!shutdown) {
+                LOG.error("As I'm leaving the listener thread, "
+                        + "I won't be able to participate in leader "
+                        + "election any longer: "
+                        + self.quorumPeers.get(self.getId()).electionAddr);
+            }
+        }
+        
+        /**
+         * Halts this listener thread.
+         */
+        void halt(){
+            try{
+                LOG.debug("Trying to close listener: " + ss);
+                if(ss != null) {
+                    LOG.debug("Closing listener: " + self.getId());
+                    ss.close();
+                }
+            } catch (IOException e){
+                LOG.warn("Exception when shutting down listener: " + e);
+            }
+        }
+    }
+
+    /**
+     * Thread to send messages. Instance waits on a queue, and send a message as
+     * soon as there is one available. If connection breaks, then opens a new
+     * one.
+     */
+    class SendWorker extends Thread {
+        Long sid;
+        Socket sock;
+        RecvWorker recvWorker;
+        volatile boolean running = true;
+        DataOutputStream dout;
+
+        /**
+         * An instance of this thread receives messages to send
+         * through a queue and sends them to the server sid.
+         * 
+         * @param sock
+         *            Socket to remote peer
+         * @param sid
+         *            Server identifier of remote peer
+         */
+        SendWorker(Socket sock, Long sid) {
+            super("SendWorker:" + sid);
+            this.sid = sid;
+            this.sock = sock;
+            recvWorker = null;
+            try {
+                dout = new DataOutputStream(sock.getOutputStream());
+            } catch (IOException e) {
+                LOG.error("Unable to access socket output stream", e);
+                closeSocket(sock);
+                running = false;
+            }
+            LOG.debug("Address of remote peer: " + this.sid);
+        }
+
+        synchronized void setRecv(RecvWorker recvWorker) {
+            this.recvWorker = recvWorker;
+        }
+
+        /**
+         * Returns RecvWorker that pairs up with this SendWorker.
+         * 
+         * @return RecvWorker 
+         */
+        synchronized RecvWorker getRecvWorker(){
+            return recvWorker;
+        }
+                
+        synchronized boolean finish() {
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("Calling finish for " + sid);
+            }
+            
+            if(!running){
+                /*
+                 * Avoids running finish() twice. 
+                 */
+                return running;
+            }
+            
+            running = false;
+            closeSocket(sock);
+            // channel = null;
+
+            this.interrupt();
+            if (recvWorker != null) {
+                recvWorker.finish();
+            }
+
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("Removing entry from senderWorkerMap sid=" + sid);
+            }
+            senderWorkerMap.remove(sid, this);
+            threadCnt.decrementAndGet();
+            return running;
+        }
+        
+        synchronized void send(ByteBuffer b) throws IOException {
+            byte[] msgBytes = new byte[b.capacity()];
+            try {
+                b.position(0);
+                b.get(msgBytes);
+            } catch (BufferUnderflowException be) {
+                LOG.error("BufferUnderflowException ", be);
+                return;
+            }
+            dout.writeInt(b.capacity());
+            dout.write(b.array());
+            dout.flush();
+        }
+
+        @Override
+        public void run() {
+            threadCnt.incrementAndGet();
+            try {
+                /**
+                 * If there is nothing in the queue to send, then we
+                 * send the lastMessage to ensure that the last message
+                 * was received by the peer. The message could be dropped
+                 * in case self or the peer shutdown their connection
+                 * (and exit the thread) prior to reading/processing
+                 * the last message. Duplicate messages are handled correctly
+                 * by the peer.
+                 *
+                 * If the send queue is non-empty, then we have a recent
+                 * message than that stored in lastMessage. To avoid sending
+                 * stale message, we should send the message in the send queue.
+                 */
+                ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);
+                if (bq == null || isSendQueueEmpty(bq)) {
+                   ByteBuffer b = lastMessageSent.get(sid);
+                   if (b != null) {
+                       LOG.debug("Attempting to send lastMessage to sid=" + sid);
+                       send(b);
+                   }
+                }
+            } catch (IOException e) {
+                LOG.error("Failed to send last message. Shutting down thread.", e);
+                this.finish();
+            }
+            
+            try {
+                while (running && !shutdown && sock != null) {
+
+                    ByteBuffer b = null;
+                    try {
+                        ArrayBlockingQueue<ByteBuffer> bq = queueSendMap
+                                .get(sid);
+                        if (bq != null) {
+                            b = pollSendQueue(bq, 1000, TimeUnit.MILLISECONDS);
+                        } else {
+                            LOG.error("No queue of incoming messages for " +
+                                      "server " + sid);
+                            break;
+                        }
+
+                        if(b != null){
+                            lastMessageSent.put(sid, b);
+                            send(b);
+                        }
+                    } catch (InterruptedException e) {
+                        LOG.warn("Interrupted while waiting for message on queue",
+                                e);
+                    }
+                }
+            } catch (Exception e) {
+                LOG.warn("Exception when using channel: for id " + sid + " my id = " + 
+                        self.getId() + " error = " + e);
+            }
+            this.finish();
+            LOG.warn("Send worker leaving thread");
+        }
+    }
+
+    /**
+     * Thread to receive messages. Instance waits on a socket read. If the
+     * channel breaks, then removes itself from the pool of receivers.
+     */
+    class RecvWorker extends Thread {
+        Long sid;
+        Socket sock;
+        volatile boolean running = true;
+        DataInputStream din;
+        final SendWorker sw;
+
+        RecvWorker(Socket sock, Long sid, SendWorker sw) {
+            super("RecvWorker:" + sid);
+            this.sid = sid;
+            this.sock = sock;
+            this.sw = sw;
+            try {
+                din = new DataInputStream(sock.getInputStream());
+                // OK to wait until socket disconnects while reading.
+                sock.setSoTimeout(0);
+            } catch (IOException e) {
+                LOG.error("Error while accessing socket for " + sid, e);
+                closeSocket(sock);
+                running = false;
+            }
+        }
+        
+        /**
+         * Shuts down this worker
+         * 
+         * @return boolean  Value of variable running
+         */
+        synchronized boolean finish() {
+            if(!running){
+                /*
+                 * Avoids running finish() twice. 
+                 */
+                return running;
+            }
+            running = false;            
+
+            this.interrupt();
+            threadCnt.decrementAndGet();
+            return running;
+        }
+
+        @Override
+        public void run() {
+            threadCnt.incrementAndGet();
+            try {
+                while (running && !shutdown && sock != null) {
+                    /**
+                     * Reads the first int to determine the length of the
+                     * message
+                     */
+                    int length = din.readInt();
+                    if (length <= 0 || length > PACKETMAXSIZE) {
+                        throw new IOException(
+                                "Received packet with invalid packet: "
+                                        + length);
+                    }
+                    /**
+                     * Allocates a new ByteBuffer to receive the message
+                     */
+                    byte[] msgArray = new byte[length];
+                    din.readFully(msgArray, 0, length);
+                    ByteBuffer message = ByteBuffer.wrap(msgArray);
+                    addToRecvQueue(new Message(message.duplicate(), sid));
+                }
+            } catch (Exception e) {
+                LOG.warn("Connection broken for id " + sid + ", my id = " + 
+                        self.getId() + ", error = " , e);
+            } finally {
+                LOG.warn("Interrupting SendWorker");
+                sw.finish();
+                if (sock != null) {
+                    closeSocket(sock);
+                }
+            }
+        }
+    }
+
+    /**
+     * Inserts an element in the specified queue. If the Queue is full, this
+     * method removes an element from the head of the Queue and then inserts
+     * the element at the tail. It can happen that the an element is removed
+     * by another thread in {@link SendWorker#processMessage() processMessage}
+     * method before this method attempts to remove an element from the queue.
+     * This will cause {@link ArrayBlockingQueue#remove() remove} to throw an
+     * exception, which is safe to ignore.
+     *
+     * Unlike {@link #addToRecvQueue(Message) addToRecvQueue} this method does
+     * not need to be synchronized since there is only one thread that inserts
+     * an element in the queue and another thread that reads from the queue.
+     *
+     * @param queue
+     *          Reference to the Queue
+     * @param buffer
+     *          Reference to the buffer to be inserted in the queue
+     */
+    private void addToSendQueue(ArrayBlockingQueue<ByteBuffer> queue,
+          ByteBuffer buffer) {
+        if (queue.remainingCapacity() == 0) {
+            try {
+                queue.remove();
+            } catch (NoSuchElementException ne) {
+                // element could be removed by poll()
+                LOG.debug("Trying to remove from an empty " +
+                        "Queue. Ignoring exception " + ne);
+            }
+        }
+        try {
+            queue.add(buffer);
+        } catch (IllegalStateException ie) {
+            // This should never happen
+            LOG.error("Unable to insert an element in the queue " + ie);
+        }
+    }
+
+    /**
+     * Returns true if queue is empty.
+     * @param queue
+     *          Reference to the queue
+     * @return
+     *      true if the specified queue is empty
+     */
+    private boolean isSendQueueEmpty(ArrayBlockingQueue<ByteBuffer> queue) {
+        return queue.isEmpty();
+    }
+
+    /**
+     * Retrieves and removes buffer at the head of this queue,
+     * waiting up to the specified wait time if necessary for an element to
+     * become available.
+     *
+     * {@link ArrayBlockingQueue#poll(long, java.util.concurrent.TimeUnit)}
+     */
+    private ByteBuffer pollSendQueue(ArrayBlockingQueue<ByteBuffer> queue,
+          long timeout, TimeUnit unit) throws InterruptedException {
+       return queue.poll(timeout, unit);
+    }
+
+    /**
+     * Inserts an element in the {@link #recvQueue}. If the Queue is full, this
+     * methods removes an element from the head of the Queue and then inserts
+     * the element at the tail of the queue.
+     *
+     * This method is synchronized to achieve fairness between two threads that
+     * are trying to insert an element in the queue. Each thread checks if the
+     * queue is full, then removes the element at the head of the queue, and
+     * then inserts an element at the tail. This three-step process is done to
+     * prevent a thread from blocking while inserting an element in the queue.
+     * If we do not synchronize the call to this method, then a thread can grab
+     * a slot in the queue created by the second thread. This can cause the call
+     * to insert by the second thread to fail.
+     * Note that synchronizing this method does not block another thread
+     * from polling the queue since that synchronization is provided by the
+     * queue itself.
+     *
+     * @param msg
+     *          Reference to the message to be inserted in the queue
+     */
+    public void addToRecvQueue(Message msg) {
+        synchronized(recvQLock) {
+            if (recvQueue.remainingCapacity() == 0) {
+                try {
+                    recvQueue.remove();
+                } catch (NoSuchElementException ne) {
+                    // element could be removed by poll()
+                     LOG.debug("Trying to remove from an empty " +
+                         "recvQueue. Ignoring exception " + ne);
+                }
+            }
+            try {
+                recvQueue.add(msg);
+            } catch (IllegalStateException ie) {
+                // This should never happen
+                LOG.error("Unable to insert element in the recvQueue " + ie);
+            }
+        }
+    }
+
+    /**
+     * Retrieves and removes a message at the head of this queue,
+     * waiting up to the specified wait time if necessary for an element to
+     * become available.
+     *
+     * {@link ArrayBlockingQueue#poll(long, java.util.concurrent.TimeUnit)}
+     */
+    public Message pollRecvQueue(long timeout, TimeUnit unit)
+       throws InterruptedException {
+       return recvQueue.poll(timeout, unit);
+    }
+}
diff -uNr zookeeper-3.4.6/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java zookeeper-3.4.6-b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java
--- zookeeper-3.4.6/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java	2014-02-20 14:14:09.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java	2016-12-26 10:45:28.000000000 +0400
@@ -26,8 +26,10 @@
 import java.io.OutputStreamWriter;
 import java.net.DatagramPacket;
 import java.net.DatagramSocket;
+import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.SocketException;
+import java.net.UnknownHostException;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -92,20 +94,20 @@
     private ZKDatabase zkDb;
 
     public static class QuorumServer {
-        public QuorumServer(long id, InetSocketAddress addr,
+        private QuorumServer(long id, InetSocketAddress addr,
                 InetSocketAddress electionAddr) {
             this.id = id;
             this.addr = addr;
             this.electionAddr = electionAddr;
         }
 
-        public QuorumServer(long id, InetSocketAddress addr) {
+        private QuorumServer(long id, InetSocketAddress addr) {
             this.id = id;
             this.addr = addr;
             this.electionAddr = null;
         }
         
-        public QuorumServer(long id, InetSocketAddress addr,
+        private QuorumServer(long id, InetSocketAddress addr,
                     InetSocketAddress electionAddr, LearnerType type) {
             this.id = id;
             this.addr = addr;
@@ -113,10 +115,67 @@
             this.type = type;
         }
         
+        public QuorumServer(long id, String hostname,
+                            Integer port, Integer electionPort,
+                            LearnerType type) {
+	        this.id = id;
+	        this.hostname=hostname;
+	        if (port!=null){
+                this.port=port;
+	        }
+	        if (electionPort!=null){
+                this.electionPort=electionPort;
+	        }
+	        if (type!=null){
+                this.type = type;
+	        }
+	        this.recreateSocketAddresses();
+	    }
+
+        /**
+         * Performs a DNS lookup of hostname and (re)creates the this.addr and
+         * this.electionAddr InetSocketAddress objects as appropriate
+         *
+         * If the DNS lookup fails, this.addr and electionAddr remain
+         * unmodified, unless they were never set. If this.addr is null, then
+         * it is set with an unresolved InetSocketAddress object. this.electionAddr
+         * is handled similarly.
+         */
+        public void recreateSocketAddresses() {
+            InetAddress address = null;
+            try {
+                address = InetAddress.getByName(this.hostname);
+                LOG.info("Resolved hostname: {} to address: {}", this.hostname, address);
+                this.addr = new InetSocketAddress(address, this.port);
+                if (this.electionPort > 0){
+                    this.electionAddr = new InetSocketAddress(address, this.electionPort);
+                }
+            } catch (UnknownHostException ex) {
+                LOG.warn("Failed to resolve address: {}", this.hostname, ex);
+                // Have we succeeded in the past?
+                if (this.addr != null) {
+                    // Yes, previously the lookup succeeded. Leave things as they are
+                    return;
+                }
+                // The hostname has never resolved. Create our InetSocketAddress(es) as unresolved
+                this.addr = InetSocketAddress.createUnresolved(this.hostname, this.port);
+                if (this.electionPort > 0){
+                    this.electionAddr = InetSocketAddress.createUnresolved(this.hostname,
+                                                                           this.electionPort);
+                }
+            }
+        }
+
         public InetSocketAddress addr;
 
         public InetSocketAddress electionAddr;
         
+        public String hostname;
+
+        public int port=2888;
+
+        public int electionPort=-1;
+
         public long id;
         
         public LearnerType type = LearnerType.PARTICIPANT;
diff -uNr zookeeper-3.4.6/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java.orig zookeeper-3.4.6-b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java.orig
--- zookeeper-3.4.6/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java.orig	1970-01-01 04:00:00.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java.orig	2014-02-20 14:14:09.000000000 +0400
@@ -0,0 +1,1249 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server.quorum;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.net.DatagramPacket;
+import java.net.DatagramSocket;
+import java.net.InetSocketAddress;
+import java.net.SocketException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.zookeeper.common.AtomicFileOutputStream;
+import org.apache.zookeeper.jmx.MBeanRegistry;
+import org.apache.zookeeper.jmx.ZKMBeanInfo;
+import org.apache.zookeeper.server.ServerCnxnFactory;
+import org.apache.zookeeper.server.ZKDatabase;
+import org.apache.zookeeper.server.ZooKeeperServer;
+import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
+import org.apache.zookeeper.server.quorum.flexible.QuorumMaj;
+import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
+import org.apache.zookeeper.server.util.ZxidUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * This class manages the quorum protocol. There are three states this server
+ * can be in:
+ * <ol>
+ * <li>Leader election - each server will elect a leader (proposing itself as a
+ * leader initially).</li>
+ * <li>Follower - the server will synchronize with the leader and replicate any
+ * transactions.</li>
+ * <li>Leader - the server will process requests and forward them to followers.
+ * A majority of followers must log the request before it can be accepted.
+ * </ol>
+ *
+ * This class will setup a datagram socket that will always respond with its
+ * view of the current leader. The response will take the form of:
+ *
+ * <pre>
+ * int xid;
+ *
+ * long myid;
+ *
+ * long leader_id;
+ *
+ * long leader_zxid;
+ * </pre>
+ *
+ * The request for the current leader will consist solely of an xid: int xid;
+ */
+public class QuorumPeer extends Thread implements QuorumStats.Provider {
+    private static final Logger LOG = LoggerFactory.getLogger(QuorumPeer.class);
+
+    QuorumBean jmxQuorumBean;
+    LocalPeerBean jmxLocalPeerBean;
+    LeaderElectionBean jmxLeaderElectionBean;
+    QuorumCnxManager qcm;
+
+    /* ZKDatabase is a top level member of quorumpeer 
+     * which will be used in all the zookeeperservers
+     * instantiated later. Also, it is created once on 
+     * bootup and only thrown away in case of a truncate
+     * message from the leader
+     */
+    private ZKDatabase zkDb;
+
+    public static class QuorumServer {
+        public QuorumServer(long id, InetSocketAddress addr,
+                InetSocketAddress electionAddr) {
+            this.id = id;
+            this.addr = addr;
+            this.electionAddr = electionAddr;
+        }
+
+        public QuorumServer(long id, InetSocketAddress addr) {
+            this.id = id;
+            this.addr = addr;
+            this.electionAddr = null;
+        }
+        
+        public QuorumServer(long id, InetSocketAddress addr,
+                    InetSocketAddress electionAddr, LearnerType type) {
+            this.id = id;
+            this.addr = addr;
+            this.electionAddr = electionAddr;
+            this.type = type;
+        }
+        
+        public InetSocketAddress addr;
+
+        public InetSocketAddress electionAddr;
+        
+        public long id;
+        
+        public LearnerType type = LearnerType.PARTICIPANT;
+    }
+
+    public enum ServerState {
+        LOOKING, FOLLOWING, LEADING, OBSERVING;
+    }
+    
+    /*
+     * A peer can either be participating, which implies that it is willing to
+     * both vote in instances of consensus and to elect or become a Leader, or
+     * it may be observing in which case it isn't.
+     * 
+     * We need this distinction to decide which ServerState to move to when 
+     * conditions change (e.g. which state to become after LOOKING). 
+     */
+    public enum LearnerType {
+        PARTICIPANT, OBSERVER;
+    }
+    
+    /*
+     * To enable observers to have no identifier, we need a generic identifier
+     * at least for QuorumCnxManager. We use the following constant to as the
+     * value of such a generic identifier. 
+     */
+    
+    static final long OBSERVER_ID = Long.MAX_VALUE;
+
+    /*
+     * Record leader election time
+     */
+    public long start_fle, end_fle;
+    
+    /*
+     * Default value of peer is participant
+     */
+    private LearnerType learnerType = LearnerType.PARTICIPANT;
+    
+    public LearnerType getLearnerType() {
+        return learnerType;
+    }
+    
+    /**
+     * Sets the LearnerType both in the QuorumPeer and in the peerMap
+     */
+    public void setLearnerType(LearnerType p) {
+        learnerType = p;
+        if (quorumPeers.containsKey(this.myid)) {
+            this.quorumPeers.get(myid).type = p;
+        } else {
+            LOG.error("Setting LearnerType to " + p + " but " + myid 
+                    + " not in QuorumPeers. ");
+        }
+        
+    }
+    /**
+     * The servers that make up the cluster
+     */
+    protected Map<Long, QuorumServer> quorumPeers;
+    public int getQuorumSize(){
+        return getVotingView().size();
+    }
+    
+    /**
+     * QuorumVerifier implementation; default (majority). 
+     */
+    
+    private QuorumVerifier quorumConfig;
+    
+    /**
+     * My id
+     */
+    private long myid;
+
+
+    /**
+     * get the id of this quorum peer.
+     */
+    public long getId() {
+        return myid;
+    }
+
+    /**
+     * This is who I think the leader currently is.
+     */
+    volatile private Vote currentVote;
+    
+    /**
+     * ... and its counterpart for backward compatibility
+     */
+    volatile private Vote bcVote;
+        
+    public synchronized Vote getCurrentVote(){
+        return currentVote;
+    }
+       
+    public synchronized void setCurrentVote(Vote v){
+        currentVote = v;
+    }
+    
+    synchronized Vote getBCVote() {
+        if (bcVote == null) {
+            return currentVote;
+        } else {
+            return bcVote;
+        }
+    }
+
+    synchronized void setBCVote(Vote v) {
+        bcVote = v;
+    }
+    
+    volatile boolean running = true;
+
+    /**
+     * The number of milliseconds of each tick
+     */
+    protected int tickTime;
+
+    /**
+     * Minimum number of milliseconds to allow for session timeout.
+     * A value of -1 indicates unset, use default.
+     */
+    protected int minSessionTimeout = -1;
+
+    /**
+     * Maximum number of milliseconds to allow for session timeout.
+     * A value of -1 indicates unset, use default.
+     */
+    protected int maxSessionTimeout = -1;
+
+    /**
+     * The number of ticks that the initial synchronization phase can take
+     */
+    protected int initLimit;
+
+    /**
+     * The number of ticks that can pass between sending a request and getting
+     * an acknowledgment
+     */
+    protected int syncLimit;
+    
+    /**
+     * Enables/Disables sync request processor. This option is enabled
+     * by default and is to be used with observers.
+     */
+    protected boolean syncEnabled = true;
+
+    /**
+     * The current tick
+     */
+    protected volatile int tick;
+
+    /**
+     * Whether or not to listen on all IPs for the two quorum ports
+     * (broadcast and fast leader election).
+     */
+    protected boolean quorumListenOnAllIPs = false;
+
+    /**
+     * @deprecated As of release 3.4.0, this class has been deprecated, since
+     * it is used with one of the udp-based versions of leader election, which
+     * we are also deprecating. 
+     * 
+     * This class simply responds to requests for the current leader of this
+     * node.
+     * <p>
+     * The request contains just an xid generated by the requestor.
+     * <p>
+     * The response has the xid, the id of this server, the id of the leader,
+     * and the zxid of the leader.
+     *
+     *
+     */
+    @Deprecated
+    class ResponderThread extends Thread {
+        ResponderThread() {
+            super("ResponderThread");
+        }
+
+        volatile boolean running = true;
+        
+        @Override
+        public void run() {
+            try {
+                byte b[] = new byte[36];
+                ByteBuffer responseBuffer = ByteBuffer.wrap(b);
+                DatagramPacket packet = new DatagramPacket(b, b.length);
+                while (running) {
+                    udpSocket.receive(packet);
+                    if (packet.getLength() != 4) {
+                        LOG.warn("Got more than just an xid! Len = "
+                                + packet.getLength());
+                    } else {
+                        responseBuffer.clear();
+                        responseBuffer.getInt(); // Skip the xid
+                        responseBuffer.putLong(myid);
+                        Vote current = getCurrentVote();
+                        switch (getPeerState()) {
+                        case LOOKING:
+                            responseBuffer.putLong(current.getId());
+                            responseBuffer.putLong(current.getZxid());
+                            break;
+                        case LEADING:
+                            responseBuffer.putLong(myid);
+                            try {
+                                long proposed;
+                                synchronized(leader) {
+                                    proposed = leader.lastProposed;
+                                }
+                                responseBuffer.putLong(proposed);
+                            } catch (NullPointerException npe) {
+                                // This can happen in state transitions,
+                                // just ignore the request
+                            }
+                            break;
+                        case FOLLOWING:
+                            responseBuffer.putLong(current.getId());
+                            try {
+                                responseBuffer.putLong(follower.getZxid());
+                            } catch (NullPointerException npe) {
+                                // This can happen in state transitions,
+                                // just ignore the request
+                            }
+                            break;
+                        case OBSERVING:
+                            // Do nothing, Observers keep themselves to
+                            // themselves. 
+                            break;
+                        }
+                        packet.setData(b);
+                        udpSocket.send(packet);
+                    }
+                    packet.setLength(b.length);
+                }
+            } catch (RuntimeException e) {
+                LOG.warn("Unexpected runtime exception in ResponderThread",e);
+            } catch (IOException e) {
+                LOG.warn("Unexpected IO exception in ResponderThread",e);
+            } finally {
+                LOG.warn("QuorumPeer responder thread exited");
+            }
+        }
+    }
+
+    private ServerState state = ServerState.LOOKING;
+
+    public synchronized void setPeerState(ServerState newState){
+        state=newState;
+    }
+
+    public synchronized ServerState getPeerState(){
+        return state;
+    }
+
+    DatagramSocket udpSocket;
+
+    private InetSocketAddress myQuorumAddr;
+
+    public InetSocketAddress getQuorumAddress(){
+        return myQuorumAddr;
+    }
+
+    private int electionType;
+
+    Election electionAlg;
+
+    ServerCnxnFactory cnxnFactory;
+    private FileTxnSnapLog logFactory = null;
+
+    private final QuorumStats quorumStats;
+    
+    public QuorumPeer() {
+        super("QuorumPeer");
+        quorumStats = new QuorumStats(this);
+    }
+    
+   
+    /**
+     * For backward compatibility purposes, we instantiate QuorumMaj by default.
+     */
+    
+    public QuorumPeer(Map<Long, QuorumServer> quorumPeers, File dataDir,
+            File dataLogDir, int electionType,
+            long myid, int tickTime, int initLimit, int syncLimit,
+            ServerCnxnFactory cnxnFactory) throws IOException {
+        this(quorumPeers, dataDir, dataLogDir, electionType, myid, tickTime, 
+        		initLimit, syncLimit, false, cnxnFactory, 
+        		new QuorumMaj(countParticipants(quorumPeers)));
+    }
+    
+    public QuorumPeer(Map<Long, QuorumServer> quorumPeers, File dataDir,
+            File dataLogDir, int electionType,
+            long myid, int tickTime, int initLimit, int syncLimit,
+            boolean quorumListenOnAllIPs,
+            ServerCnxnFactory cnxnFactory, 
+            QuorumVerifier quorumConfig) throws IOException {
+        this();
+        this.cnxnFactory = cnxnFactory;
+        this.quorumPeers = quorumPeers;
+        this.electionType = electionType;
+        this.myid = myid;
+        this.tickTime = tickTime;
+        this.initLimit = initLimit;
+        this.syncLimit = syncLimit;        
+        this.quorumListenOnAllIPs = quorumListenOnAllIPs;
+        this.logFactory = new FileTxnSnapLog(dataLogDir, dataDir);
+        this.zkDb = new ZKDatabase(this.logFactory);
+        if(quorumConfig == null)
+            this.quorumConfig = new QuorumMaj(countParticipants(quorumPeers));
+        else this.quorumConfig = quorumConfig;
+    }
+    
+    QuorumStats quorumStats() {
+        return quorumStats;
+    }
+    
+    @Override
+    public synchronized void start() {
+        loadDataBase();
+        cnxnFactory.start();        
+        startLeaderElection();
+        super.start();
+    }
+
+    private void loadDataBase() {
+        File updating = new File(getTxnFactory().getSnapDir(),
+                                 UPDATING_EPOCH_FILENAME);
+		try {
+            zkDb.loadDataBase();
+
+            // load the epochs
+            long lastProcessedZxid = zkDb.getDataTree().lastProcessedZxid;
+    		long epochOfZxid = ZxidUtils.getEpochFromZxid(lastProcessedZxid);
+            try {
+            	currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);
+                if (epochOfZxid > currentEpoch && updating.exists()) {
+                    LOG.info("{} found. The server was terminated after " +
+                             "taking a snapshot but before updating current " +
+                             "epoch. Setting current epoch to {}.",
+                             UPDATING_EPOCH_FILENAME, epochOfZxid);
+                    setCurrentEpoch(epochOfZxid);
+                    if (!updating.delete()) {
+                        throw new IOException("Failed to delete " +
+                                              updating.toString());
+                    }
+                }
+            } catch(FileNotFoundException e) {
+            	// pick a reasonable epoch number
+            	// this should only happen once when moving to a
+            	// new code version
+            	currentEpoch = epochOfZxid;
+            	LOG.info(CURRENT_EPOCH_FILENAME
+            	        + " not found! Creating with a reasonable default of {}. This should only happen when you are upgrading your installation",
+            	        currentEpoch);
+            	writeLongToFile(CURRENT_EPOCH_FILENAME, currentEpoch);
+            }
+            if (epochOfZxid > currentEpoch) {
+            	throw new IOException("The current epoch, " + ZxidUtils.zxidToString(currentEpoch) + ", is older than the last zxid, " + lastProcessedZxid);
+            }
+            try {
+            	acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);
+            } catch(FileNotFoundException e) {
+            	// pick a reasonable epoch number
+            	// this should only happen once when moving to a
+            	// new code version
+            	acceptedEpoch = epochOfZxid;
+            	LOG.info(ACCEPTED_EPOCH_FILENAME
+            	        + " not found! Creating with a reasonable default of {}. This should only happen when you are upgrading your installation",
+            	        acceptedEpoch);
+            	writeLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch);
+            }
+            if (acceptedEpoch < currentEpoch) {
+            	throw new IOException("The current epoch, " + ZxidUtils.zxidToString(currentEpoch) + " is less than the accepted epoch, " + ZxidUtils.zxidToString(acceptedEpoch));
+            }
+        } catch(IOException ie) {
+            LOG.error("Unable to load database on disk", ie);
+            throw new RuntimeException("Unable to run quorum server ", ie);
+        }
+	}
+
+    ResponderThread responder;
+    
+    synchronized public void stopLeaderElection() {
+        responder.running = false;
+        responder.interrupt();
+    }
+    synchronized public void startLeaderElection() {
+    	try {
+    		currentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch());
+    	} catch(IOException e) {
+    		RuntimeException re = new RuntimeException(e.getMessage());
+    		re.setStackTrace(e.getStackTrace());
+    		throw re;
+    	}
+        for (QuorumServer p : getView().values()) {
+            if (p.id == myid) {
+                myQuorumAddr = p.addr;
+                break;
+            }
+        }
+        if (myQuorumAddr == null) {
+            throw new RuntimeException("My id " + myid + " not in the peer list");
+        }
+        if (electionType == 0) {
+            try {
+                udpSocket = new DatagramSocket(myQuorumAddr.getPort());
+                responder = new ResponderThread();
+                responder.start();
+            } catch (SocketException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        this.electionAlg = createElectionAlgorithm(electionType);
+    }
+    
+    /**
+     * Count the number of nodes in the map that could be followers.
+     * @param peers
+     * @return The number of followers in the map
+     */
+    protected static int countParticipants(Map<Long,QuorumServer> peers) {
+      int count = 0;
+      for (QuorumServer q : peers.values()) {
+          if (q.type == LearnerType.PARTICIPANT) {
+              count++;
+          }
+      }
+      return count;
+    }
+    
+    /**
+     * This constructor is only used by the existing unit test code.
+     * It defaults to FileLogProvider persistence provider.
+     */
+    public QuorumPeer(Map<Long,QuorumServer> quorumPeers, File snapDir,
+            File logDir, int clientPort, int electionAlg,
+            long myid, int tickTime, int initLimit, int syncLimit)
+        throws IOException
+    {
+        this(quorumPeers, snapDir, logDir, electionAlg,
+                myid,tickTime, initLimit,syncLimit, false,
+                ServerCnxnFactory.createFactory(new InetSocketAddress(clientPort), -1),
+                new QuorumMaj(countParticipants(quorumPeers)));
+    }
+    
+    /**
+     * This constructor is only used by the existing unit test code.
+     * It defaults to FileLogProvider persistence provider.
+     */
+    public QuorumPeer(Map<Long,QuorumServer> quorumPeers, File snapDir,
+            File logDir, int clientPort, int electionAlg,
+            long myid, int tickTime, int initLimit, int syncLimit, 
+            QuorumVerifier quorumConfig)
+        throws IOException
+    {
+        this(quorumPeers, snapDir, logDir, electionAlg,
+                myid,tickTime, initLimit,syncLimit, false,
+                ServerCnxnFactory.createFactory(new InetSocketAddress(clientPort), -1),
+                quorumConfig);
+    }
+    
+    /**
+     * returns the highest zxid that this host has seen
+     * 
+     * @return the highest zxid for this host
+     */
+    public long getLastLoggedZxid() {
+        if (!zkDb.isInitialized()) {
+        	loadDataBase();
+        }
+        return zkDb.getDataTreeLastProcessedZxid();
+    }
+    
+    public Follower follower;
+    public Leader leader;
+    public Observer observer;
+
+    protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException {
+        return new Follower(this, new FollowerZooKeeperServer(logFactory, 
+                this,new ZooKeeperServer.BasicDataTreeBuilder(), this.zkDb));
+    }
+     
+    protected Leader makeLeader(FileTxnSnapLog logFactory) throws IOException {
+        return new Leader(this, new LeaderZooKeeperServer(logFactory,
+                this,new ZooKeeperServer.BasicDataTreeBuilder(), this.zkDb));
+    }
+    
+    protected Observer makeObserver(FileTxnSnapLog logFactory) throws IOException {
+        return new Observer(this, new ObserverZooKeeperServer(logFactory,
+                this, new ZooKeeperServer.BasicDataTreeBuilder(), this.zkDb));
+    }
+
+    protected Election createElectionAlgorithm(int electionAlgorithm){
+        Election le=null;
+                
+        //TODO: use a factory rather than a switch
+        switch (electionAlgorithm) {
+        case 0:
+            le = new LeaderElection(this);
+            break;
+        case 1:
+            le = new AuthFastLeaderElection(this);
+            break;
+        case 2:
+            le = new AuthFastLeaderElection(this, true);
+            break;
+        case 3:
+            qcm = new QuorumCnxManager(this);
+            QuorumCnxManager.Listener listener = qcm.listener;
+            if(listener != null){
+                listener.start();
+                le = new FastLeaderElection(this, qcm);
+            } else {
+                LOG.error("Null listener when initializing cnx manager");
+            }
+            break;
+        default:
+            assert false;
+        }
+        return le;
+    }
+
+    protected Election makeLEStrategy(){
+        LOG.debug("Initializing leader election protocol...");
+        if (getElectionType() == 0) {
+            electionAlg = new LeaderElection(this);
+        }        
+        return electionAlg;
+    }
+
+    synchronized protected void setLeader(Leader newLeader){
+        leader=newLeader;
+    }
+
+    synchronized protected void setFollower(Follower newFollower){
+        follower=newFollower;
+    }
+    
+    synchronized protected void setObserver(Observer newObserver){
+        observer=newObserver;
+    }
+
+    synchronized public ZooKeeperServer getActiveServer(){
+        if(leader!=null)
+            return leader.zk;
+        else if(follower!=null)
+            return follower.zk;
+        else if (observer != null)
+            return observer.zk;
+        return null;
+    }
+
+    @Override
+    public void run() {
+        setName("QuorumPeer" + "[myid=" + getId() + "]" +
+                cnxnFactory.getLocalAddress());
+
+        LOG.debug("Starting quorum peer");
+        try {
+            jmxQuorumBean = new QuorumBean(this);
+            MBeanRegistry.getInstance().register(jmxQuorumBean, null);
+            for(QuorumServer s: getView().values()){
+                ZKMBeanInfo p;
+                if (getId() == s.id) {
+                    p = jmxLocalPeerBean = new LocalPeerBean(this);
+                    try {
+                        MBeanRegistry.getInstance().register(p, jmxQuorumBean);
+                    } catch (Exception e) {
+                        LOG.warn("Failed to register with JMX", e);
+                        jmxLocalPeerBean = null;
+                    }
+                } else {
+                    p = new RemotePeerBean(s);
+                    try {
+                        MBeanRegistry.getInstance().register(p, jmxQuorumBean);
+                    } catch (Exception e) {
+                        LOG.warn("Failed to register with JMX", e);
+                    }
+                }
+            }
+        } catch (Exception e) {
+            LOG.warn("Failed to register with JMX", e);
+            jmxQuorumBean = null;
+        }
+
+        try {
+            /*
+             * Main loop
+             */
+            while (running) {
+                switch (getPeerState()) {
+                case LOOKING:
+                    LOG.info("LOOKING");
+
+                    if (Boolean.getBoolean("readonlymode.enabled")) {
+                        LOG.info("Attempting to start ReadOnlyZooKeeperServer");
+
+                        // Create read-only server but don't start it immediately
+                        final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(
+                                logFactory, this,
+                                new ZooKeeperServer.BasicDataTreeBuilder(),
+                                this.zkDb);
+    
+                        // Instead of starting roZk immediately, wait some grace
+                        // period before we decide we're partitioned.
+                        //
+                        // Thread is used here because otherwise it would require
+                        // changes in each of election strategy classes which is
+                        // unnecessary code coupling.
+                        Thread roZkMgr = new Thread() {
+                            public void run() {
+                                try {
+                                    // lower-bound grace period to 2 secs
+                                    sleep(Math.max(2000, tickTime));
+                                    if (ServerState.LOOKING.equals(getPeerState())) {
+                                        roZk.startup();
+                                    }
+                                } catch (InterruptedException e) {
+                                    LOG.info("Interrupted while attempting to start ReadOnlyZooKeeperServer, not started");
+                                } catch (Exception e) {
+                                    LOG.error("FAILED to start ReadOnlyZooKeeperServer", e);
+                                }
+                            }
+                        };
+                        try {
+                            roZkMgr.start();
+                            setBCVote(null);
+                            setCurrentVote(makeLEStrategy().lookForLeader());
+                        } catch (Exception e) {
+                            LOG.warn("Unexpected exception",e);
+                            setPeerState(ServerState.LOOKING);
+                        } finally {
+                            // If the thread is in the the grace period, interrupt
+                            // to come out of waiting.
+                            roZkMgr.interrupt();
+                            roZk.shutdown();
+                        }
+                    } else {
+                        try {
+                            setBCVote(null);
+                            setCurrentVote(makeLEStrategy().lookForLeader());
+                        } catch (Exception e) {
+                            LOG.warn("Unexpected exception", e);
+                            setPeerState(ServerState.LOOKING);
+                        }
+                    }
+                    break;
+                case OBSERVING:
+                    try {
+                        LOG.info("OBSERVING");
+                        setObserver(makeObserver(logFactory));
+                        observer.observeLeader();
+                    } catch (Exception e) {
+                        LOG.warn("Unexpected exception",e );                        
+                    } finally {
+                        observer.shutdown();
+                        setObserver(null);
+                        setPeerState(ServerState.LOOKING);
+                    }
+                    break;
+                case FOLLOWING:
+                    try {
+                        LOG.info("FOLLOWING");
+                        setFollower(makeFollower(logFactory));
+                        follower.followLeader();
+                    } catch (Exception e) {
+                        LOG.warn("Unexpected exception",e);
+                    } finally {
+                        follower.shutdown();
+                        setFollower(null);
+                        setPeerState(ServerState.LOOKING);
+                    }
+                    break;
+                case LEADING:
+                    LOG.info("LEADING");
+                    try {
+                        setLeader(makeLeader(logFactory));
+                        leader.lead();
+                        setLeader(null);
+                    } catch (Exception e) {
+                        LOG.warn("Unexpected exception",e);
+                    } finally {
+                        if (leader != null) {
+                            leader.shutdown("Forcing shutdown");
+                            setLeader(null);
+                        }
+                        setPeerState(ServerState.LOOKING);
+                    }
+                    break;
+                }
+            }
+        } finally {
+            LOG.warn("QuorumPeer main thread exited");
+            try {
+                MBeanRegistry.getInstance().unregisterAll();
+            } catch (Exception e) {
+                LOG.warn("Failed to unregister with JMX", e);
+            }
+            jmxQuorumBean = null;
+            jmxLocalPeerBean = null;
+        }
+    }
+
+    public void shutdown() {
+        running = false;
+        if (leader != null) {
+            leader.shutdown("quorum Peer shutdown");
+        }
+        if (follower != null) {
+            follower.shutdown();
+        }
+        cnxnFactory.shutdown();
+        if(udpSocket != null) {
+            udpSocket.close();
+        }
+        
+        if(getElectionAlg() != null){
+            this.interrupt();
+        	getElectionAlg().shutdown();
+        }
+        try {
+            zkDb.close();
+        } catch (IOException ie) {
+            LOG.warn("Error closing logs ", ie);
+        }     
+    }
+
+    /**
+     * A 'view' is a node's current opinion of the membership of the entire
+     * ensemble.    
+     */
+    public Map<Long,QuorumPeer.QuorumServer> getView() {
+        return Collections.unmodifiableMap(this.quorumPeers);
+    }
+    
+    /**
+     * Observers are not contained in this view, only nodes with 
+     * PeerType=PARTICIPANT.     
+     */
+    public Map<Long,QuorumPeer.QuorumServer> getVotingView() {
+        Map<Long,QuorumPeer.QuorumServer> ret = 
+            new HashMap<Long, QuorumPeer.QuorumServer>();
+        Map<Long,QuorumPeer.QuorumServer> view = getView();
+        for (QuorumServer server : view.values()) {            
+            if (server.type == LearnerType.PARTICIPANT) {
+                ret.put(server.id, server);
+            }
+        }        
+        return ret;
+    }
+    
+    /**
+     * Returns only observers, no followers.
+     */
+    public Map<Long,QuorumPeer.QuorumServer> getObservingView() {
+        Map<Long,QuorumPeer.QuorumServer> ret = 
+            new HashMap<Long, QuorumPeer.QuorumServer>();
+        Map<Long,QuorumPeer.QuorumServer> view = getView();
+        for (QuorumServer server : view.values()) {            
+            if (server.type == LearnerType.OBSERVER) {
+                ret.put(server.id, server);
+            }
+        }        
+        return ret;
+    }
+    
+    /**
+     * Check if a node is in the current view. With static membership, the
+     * result of this check will never change; only when dynamic membership
+     * is introduced will this be more useful.
+     */
+    public boolean viewContains(Long sid) {
+        return this.quorumPeers.containsKey(sid);
+    }
+    
+    /**
+     * Only used by QuorumStats at the moment
+     */
+    public String[] getQuorumPeers() {
+        List<String> l = new ArrayList<String>();
+        synchronized (this) {
+            if (leader != null) {
+                for (LearnerHandler fh : leader.getLearners()) {
+                    if (fh.getSocket() != null) {
+                        String s = fh.getSocket().getRemoteSocketAddress().toString();
+                        if (leader.isLearnerSynced(fh))
+                            s += "*";
+                        l.add(s);
+                    }
+                }
+            } else if (follower != null) {
+                l.add(follower.sock.getRemoteSocketAddress().toString());
+            }
+        }
+        return l.toArray(new String[0]);
+    }
+
+    public String getServerState() {
+        switch (getPeerState()) {
+        case LOOKING:
+            return QuorumStats.Provider.LOOKING_STATE;
+        case LEADING:
+            return QuorumStats.Provider.LEADING_STATE;
+        case FOLLOWING:
+            return QuorumStats.Provider.FOLLOWING_STATE;
+        case OBSERVING:
+            return QuorumStats.Provider.OBSERVING_STATE;
+        }
+        return QuorumStats.Provider.UNKNOWN_STATE;
+    }
+
+
+    /**
+     * get the id of this quorum peer.
+     */
+    public long getMyid() {
+        return myid;
+    }
+
+    /**
+     * set the id of this quorum peer.
+     */
+    public void setMyid(long myid) {
+        this.myid = myid;
+    }
+
+    /**
+     * Get the number of milliseconds of each tick
+     */
+    public int getTickTime() {
+        return tickTime;
+    }
+
+    /**
+     * Set the number of milliseconds of each tick
+     */
+    public void setTickTime(int tickTime) {
+        LOG.info("tickTime set to " + tickTime);
+        this.tickTime = tickTime;
+    }
+
+    /** Maximum number of connections allowed from particular host (ip) */
+    public int getMaxClientCnxnsPerHost() {
+        ServerCnxnFactory fac = getCnxnFactory();
+        if (fac == null) {
+            return -1;
+        }
+        return fac.getMaxClientCnxnsPerHost();
+    }
+    
+    /** minimum session timeout in milliseconds */
+    public int getMinSessionTimeout() {
+        return minSessionTimeout == -1 ? tickTime * 2 : minSessionTimeout;
+    }
+
+    /** minimum session timeout in milliseconds */
+    public void setMinSessionTimeout(int min) {
+        LOG.info("minSessionTimeout set to " + min);
+        this.minSessionTimeout = min;
+    }
+
+    /** maximum session timeout in milliseconds */
+    public int getMaxSessionTimeout() {
+        return maxSessionTimeout == -1 ? tickTime * 20 : maxSessionTimeout;
+    }
+
+    /** minimum session timeout in milliseconds */
+    public void setMaxSessionTimeout(int max) {
+        LOG.info("maxSessionTimeout set to " + max);
+        this.maxSessionTimeout = max;
+    }
+
+    /**
+     * Get the number of ticks that the initial synchronization phase can take
+     */
+    public int getInitLimit() {
+        return initLimit;
+    }
+
+    /**
+     * Set the number of ticks that the initial synchronization phase can take
+     */
+    public void setInitLimit(int initLimit) {
+        LOG.info("initLimit set to " + initLimit);
+        this.initLimit = initLimit;
+    }
+
+    /**
+     * Get the current tick
+     */
+    public int getTick() {
+        return tick;
+    }
+    
+    /**
+     * Return QuorumVerifier object
+     */
+    
+    public QuorumVerifier getQuorumVerifier(){
+        return quorumConfig;
+        
+    }
+    
+    public void setQuorumVerifier(QuorumVerifier quorumConfig){
+       this.quorumConfig = quorumConfig;
+    }
+    
+    /**
+     * Get an instance of LeaderElection
+     */
+        
+    public Election getElectionAlg(){
+        return electionAlg;
+    }
+        
+    /**
+     * Get the synclimit
+     */
+    public int getSyncLimit() {
+        return syncLimit;
+    }
+
+    /**
+     * Set the synclimit
+     */
+    public void setSyncLimit(int syncLimit) {
+        this.syncLimit = syncLimit;
+    }
+    
+    
+    /**
+     * The syncEnabled can also be set via a system property.
+     */
+    public static final String SYNC_ENABLED = "zookeeper.observer.syncEnabled";
+    
+    /**
+     * Return syncEnabled.
+     * 
+     * @return
+     */
+    public boolean getSyncEnabled() {
+        if (System.getProperty(SYNC_ENABLED) != null) {
+            LOG.info(SYNC_ENABLED + "=" + Boolean.getBoolean(SYNC_ENABLED));   
+            return Boolean.getBoolean(SYNC_ENABLED);
+        } else {        
+            return syncEnabled;
+        }
+    }
+    
+    /**
+     * Set syncEnabled.
+     * 
+     * @param syncEnabled
+     */
+    public void setSyncEnabled(boolean syncEnabled) {
+        this.syncEnabled = syncEnabled;
+    }
+
+    /**
+     * Gets the election type
+     */
+    public int getElectionType() {
+        return electionType;
+    }
+
+    /**
+     * Sets the election type
+     */
+    public void setElectionType(int electionType) {
+        this.electionType = electionType;
+    }
+
+    public boolean getQuorumListenOnAllIPs() {
+        return quorumListenOnAllIPs;
+    }
+
+    public void setQuorumListenOnAllIPs(boolean quorumListenOnAllIPs) {
+        this.quorumListenOnAllIPs = quorumListenOnAllIPs;
+    }
+
+    public ServerCnxnFactory getCnxnFactory() {
+        return cnxnFactory;
+    }
+
+    public void setCnxnFactory(ServerCnxnFactory cnxnFactory) {
+        this.cnxnFactory = cnxnFactory;
+    }
+
+    public void setQuorumPeers(Map<Long,QuorumServer> quorumPeers) {
+        this.quorumPeers = quorumPeers;
+    }
+
+    public int getClientPort() {
+        return cnxnFactory.getLocalPort();
+    }
+
+    public void setClientPortAddress(InetSocketAddress addr) {
+    }
+ 
+    public void setTxnFactory(FileTxnSnapLog factory) {
+        this.logFactory = factory;
+    }
+    
+    public FileTxnSnapLog getTxnFactory() {
+        return this.logFactory;
+    }
+
+    /**
+     * set zk database for this node
+     * @param database
+     */
+    public void setZKDatabase(ZKDatabase database) {
+        this.zkDb = database;
+    }
+
+    public void setRunning(boolean running) {
+        this.running = running;
+    }
+
+    public boolean isRunning() {
+        return running;
+    }
+
+    /**
+     * get reference to QuorumCnxManager
+     */
+    public QuorumCnxManager getQuorumCnxManager() {
+        return qcm;
+    }
+    private long readLongFromFile(String name) throws IOException {
+    	File file = new File(logFactory.getSnapDir(), name);
+		BufferedReader br = new BufferedReader(new FileReader(file));
+		String line = "";
+		try {
+			line = br.readLine();
+    		return Long.parseLong(line);
+    	} catch(NumberFormatException e) {
+    		throw new IOException("Found " + line + " in " + file);
+    	} finally {
+    		br.close();
+    	}
+    }
+
+    private long acceptedEpoch = -1;
+    private long currentEpoch = -1;
+
+	public static final String CURRENT_EPOCH_FILENAME = "currentEpoch";
+
+	public static final String ACCEPTED_EPOCH_FILENAME = "acceptedEpoch";
+
+    public static final String UPDATING_EPOCH_FILENAME = "updatingEpoch";
+
+	/**
+	 * Write a long value to disk atomically. Either succeeds or an exception
+	 * is thrown.
+	 * @param name file name to write the long to
+	 * @param value the long value to write to the named file
+	 * @throws IOException if the file cannot be written atomically
+	 */
+    private void writeLongToFile(String name, long value) throws IOException {
+        File file = new File(logFactory.getSnapDir(), name);
+        AtomicFileOutputStream out = new AtomicFileOutputStream(file);
+        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(out));
+        boolean aborted = false;
+        try {
+            bw.write(Long.toString(value));
+            bw.flush();
+            
+            out.flush();
+        } catch (IOException e) {
+            LOG.error("Failed to write new file " + file, e);
+            // worst case here the tmp file/resources(fd) are not cleaned up
+            //   and the caller will be notified (IOException)
+            aborted = true;
+            out.abort();
+            throw e;
+        } finally {
+            if (!aborted) {
+                // if the close operation (rename) fails we'll get notified.
+                // worst case the tmp file may still exist
+                out.close();
+            }
+        }
+    }
+
+    public long getCurrentEpoch() throws IOException {
+		if (currentEpoch == -1) {
+			currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);
+		}
+		return currentEpoch;
+	}
+	
+	public long getAcceptedEpoch() throws IOException {
+		if (acceptedEpoch == -1) {
+			acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);
+		}
+		return acceptedEpoch;
+	}
+	
+	public void setCurrentEpoch(long e) throws IOException {
+		currentEpoch = e;
+		writeLongToFile(CURRENT_EPOCH_FILENAME, e);
+		
+	}
+	
+	public void setAcceptedEpoch(long e) throws IOException {
+		acceptedEpoch = e;
+		writeLongToFile(ACCEPTED_EPOCH_FILENAME, e);
+	}
+
+    /**
+     * Updates leader election info to avoid inconsistencies when
+     * a new server tries to join the ensemble.
+     * See ZOOKEEPER-1732 for more info.
+     */
+    protected void updateElectionVote(long newEpoch) {
+        Vote currentVote = getCurrentVote();
+        setBCVote(currentVote);
+        if (currentVote != null) {
+            setCurrentVote(new Vote(currentVote.getId(),
+                currentVote.getZxid(),
+                currentVote.getElectionEpoch(),
+                newEpoch,
+                currentVote.getState()));
+        }
+    }
+
+}
diff -uNr zookeeper-3.4.6/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java zookeeper-3.4.6-b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java
--- zookeeper-3.4.6/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java	2014-02-20 14:14:09.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java	2016-12-26 10:45:28.000000000 +0400
@@ -185,31 +185,27 @@
                        + " does not have the form host:port or host:port:port " +
                        " or host:port:port:type");
                 }
-                InetSocketAddress addr = new InetSocketAddress(parts[0],
-                        Integer.parseInt(parts[1]));
-                if (parts.length == 2) {
-                    servers.put(Long.valueOf(sid), new QuorumServer(sid, addr));
-                } else if (parts.length == 3) {
-                    InetSocketAddress electionAddr = new InetSocketAddress(
-                            parts[0], Integer.parseInt(parts[2]));
-                    servers.put(Long.valueOf(sid), new QuorumServer(sid, addr,
-                            electionAddr));
-                } else if (parts.length == 4) {
-                    InetSocketAddress electionAddr = new InetSocketAddress(
-                            parts[0], Integer.parseInt(parts[2]));
-                    LearnerType type = LearnerType.PARTICIPANT;
+                LearnerType type = null;
+                String hostname=parts[0];
+                Integer port=Integer.parseInt(parts[1]);
+                Integer electionPort=null;
+                if (parts.length>2){
+                	electionPort=Integer.parseInt(parts[2]);
+                }
+                if (parts.length>3){
                     if (parts[3].toLowerCase().equals("observer")) {
                         type = LearnerType.OBSERVER;
-                        observers.put(Long.valueOf(sid), new QuorumServer(sid, addr,
-                                electionAddr,type));
                     } else if (parts[3].toLowerCase().equals("participant")) {
                         type = LearnerType.PARTICIPANT;
-                        servers.put(Long.valueOf(sid), new QuorumServer(sid, addr,
-                                electionAddr,type));
                     } else {
                         throw new ConfigException("Unrecognised peertype: " + value);
                     }
                 }
+                if (type == LearnerType.OBSERVER){
+                    observers.put(Long.valueOf(sid), new QuorumServer(sid, hostname, port, electionPort, type));
+                } else {
+                    servers.put(Long.valueOf(sid), new QuorumServer(sid, hostname, port, electionPort, type));
+                }
             } else if (key.startsWith("group")) {
                 int dot = key.indexOf('.');
                 long gid = Long.parseLong(key.substring(dot + 1));
diff -uNr zookeeper-3.4.6/src/java/systest/org/apache/zookeeper/test/system/BaseSysTest.java zookeeper-3.4.6-b/src/java/systest/org/apache/zookeeper/test/system/BaseSysTest.java
--- zookeeper-3.4.6/src/java/systest/org/apache/zookeeper/test/system/BaseSysTest.java	2014-02-20 14:14:09.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/systest/org/apache/zookeeper/test/system/BaseSysTest.java	2016-12-26 10:46:59.000000000 +0400
@@ -145,7 +145,8 @@
         qps = new QuorumPeer[count];
         qpsDirs = new File[count];
         for(int i = 1; i <= count; i++) {
-            peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress("127.0.0.1", fakeBasePort + i)));
+             peers.put(Long.valueOf(i), new QuorumServer(
+                 i, "127.0.0.1", fakeBasePort + i, serverCount + fakeBasePort + i, null));
         }
         StringBuilder sb = new StringBuilder();
         for(int i = 0; i < count; i++) {
diff -uNr zookeeper-3.4.6/src/java/systest/org/apache/zookeeper/test/system/BaseSysTest.java.orig zookeeper-3.4.6-b/src/java/systest/org/apache/zookeeper/test/system/BaseSysTest.java.orig
--- zookeeper-3.4.6/src/java/systest/org/apache/zookeeper/test/system/BaseSysTest.java.orig	1970-01-01 04:00:00.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/systest/org/apache/zookeeper/test/system/BaseSysTest.java.orig	2014-02-20 14:14:09.000000000 +0400
@@ -0,0 +1,266 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.test.system;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.UnknownHostException;
+import java.util.HashMap;
+
+import junit.framework.TestCase;
+
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.server.quorum.QuorumPeer;
+import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;
+import org.junit.Ignore;
+import org.junit.runner.JUnitCore;
+
+@Ignore("No tests in this class.")
+public class BaseSysTest extends TestCase {
+    private static int fakeBasePort = 33222;
+    private static String zkHostPort;
+    protected String prefix = "/sysTest";
+    ZooKeeper zk;
+    static {
+        try {
+            zkHostPort = System.getProperty("sysTest.zkHostPort", InetAddress.getLocalHost().getCanonicalHostName() + ":2181");
+        } catch (UnknownHostException e) {
+            e.printStackTrace();
+        }
+    }
+    InstanceManager im;
+    @Override
+    protected void setUp() throws Exception {
+        if (!fakeMachines) {
+            String localHost = InetAddress.getLocalHost().getCanonicalHostName();
+            zk = new ZooKeeper(zkHostPort, 15000, new Watcher() {public void process(WatchedEvent e){}});
+            im = new InstanceManager(zk, prefix);
+        }
+    }
+    @Override
+    protected void tearDown() throws Exception {
+        im.close();
+    }
+
+    int serverCount = defaultServerCount;
+    int clientCount = defaultClientCount;
+    static int defaultServerCount = 5;
+    static int defaultClientCount = 7;
+    static {
+        defaultServerCount = Integer.parseInt(System.getProperty("simpleSysTest.defaultServerCount", Integer.toString(defaultServerCount)));
+        defaultClientCount = Integer.parseInt(System.getProperty("simpleSysTest.defaultClientCount", Integer.toString(defaultClientCount)));
+    }
+
+    String serverHostPort;
+    String quorumHostPort;
+    public String getHostPort() {
+        return serverHostPort;
+    }
+    public int getServerCount() {
+        return serverCount;
+    }
+    public int getClientCount() {
+        return clientCount;
+    }
+
+    public void startServers() throws IOException {
+        for(int i = 0; i < serverCount; i++) {
+            startServer(i);
+        }
+    }
+    public void stopServers() throws IOException {
+        for(int i = 0; i < serverCount; i++) {
+            stopServer(i);
+        }
+    }
+    public void startClients() throws IOException {
+        for(int i = 0; i < clientCount; i++) {
+            startClient(i);
+        }
+    }
+    public void stopClients() throws IOException {
+        for(int i = 0; i < clientCount; i++) {
+            stopClient(i);
+        }
+    }
+
+    private static boolean fakeMachines = System.getProperty("baseSysTest.fakeMachines", "no").equals("yes");
+
+    public void configureServers(int count) throws Exception {
+        serverCount = count;
+        if (fakeMachines) {
+            fakeConfigureServers(count);
+        } else {
+            distributedConfigureServers(count);
+        }
+    }
+
+    private void distributedConfigureServers(int count) throws IOException {
+        StringBuilder sbClient = new StringBuilder();
+        StringBuilder sbServer = new StringBuilder();
+        try {
+            for(int i = 0; i < count; i++) {
+                String r[] = QuorumPeerInstance.createServer(im, i);
+                if (i > 0) {
+                    sbClient.append(',');
+                    sbServer.append(',');
+                }
+                sbClient.append(r[0]);
+                sbServer.append(r[1]);
+            }
+            serverHostPort = sbClient.toString();
+            quorumHostPort = sbServer.toString();
+        } catch(Exception e) {
+            IOException ioe = new IOException(e.getMessage());
+            ioe.setStackTrace(e.getStackTrace());
+            throw ioe;
+        }
+    }
+
+    private QuorumPeer qps[];
+    private File qpsDirs[];
+    HashMap<Long,QuorumServer> peers;
+    private void fakeConfigureServers(int count) throws IOException {
+        peers = new HashMap<Long,QuorumServer>();
+        qps = new QuorumPeer[count];
+        qpsDirs = new File[count];
+        for(int i = 1; i <= count; i++) {
+            peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress("127.0.0.1", fakeBasePort + i)));
+        }
+        StringBuilder sb = new StringBuilder();
+        for(int i = 0; i < count; i++) {
+            qpsDirs[i] = File.createTempFile("sysTest", ".tmp");
+            qpsDirs[i].delete();
+            qpsDirs[i].mkdir();
+            int port = fakeBasePort+10+i;
+            if (sb.length() > 0) {
+                sb.append(',');
+            }
+            sb.append("localhost:");
+            sb.append(port);
+        }
+        serverHostPort = sb.toString();
+    }
+    final static int tickTime = 2000;
+    final static int initLimit = 3;
+    final static int syncLimit = 3;
+
+    public void startServer(int index) throws IOException {
+        int port = fakeBasePort+10+index;
+        if (fakeMachines) {
+            qps[index] = new QuorumPeer(peers, qpsDirs[index], qpsDirs[index], port, 0, index+1, tickTime, initLimit, syncLimit);
+            qps[index].start();
+        } else {
+            try {
+                QuorumPeerInstance.startInstance(im, quorumHostPort, index);
+            } catch(Exception e) {
+                IOException ioe = new IOException(e.getClass().getName() + ": " + e.getMessage());
+                ioe.setStackTrace(e.getStackTrace());
+                throw ioe;
+            }
+        }
+    }
+    public void stopServer(int index) throws IOException {
+        if (fakeMachines) {
+            qps[index].shutdown();
+        } else {
+            try {
+                QuorumPeerInstance.stopInstance(im, index);
+            } catch(Exception e) {
+                IOException ioe = new IOException(e.getMessage());
+                ioe.setStackTrace(e.getStackTrace());
+                throw ioe;
+            }
+        }
+    }
+
+    public void configureClients(int count, Class<? extends Instance> clazz, String params) throws Exception {
+        clientCount = count;
+        if (fakeMachines) {
+            fakeConfigureClients(count, clazz, params);
+        } else {
+            distributedConfigureClients(count, clazz, params);
+        }
+    }
+    private Class<? extends Instance> clazz;
+    String params;
+    private void distributedConfigureClients(int count, Class<? extends Instance> clazz, String params) throws IOException {
+        this.clazz = clazz;
+        this.params = params;
+
+    }
+    private Instance fakeBaseClients[];
+    private void fakeConfigureClients(int count, Class<? extends Instance> clazz, String params) throws IOException, ClassNotFoundException {
+        fakeBaseClients = new Instance[count];
+        for(int i = 0; i < count; i++) {
+            try {
+                fakeBaseClients[i] = clazz.newInstance();
+            } catch (InstantiationException e) {
+                e.printStackTrace();
+                return;
+            } catch (IllegalAccessException e) {
+                e.printStackTrace();
+                return;
+            }
+            fakeBaseClients[i].configure(i + " " + params);
+        }
+    }
+    public void startClient(int index) throws IOException {
+        if (fakeMachines) {
+            fakeStartClient(index);
+        } else {
+            distributedStartClient(index);
+        }
+    }
+    private void distributedStartClient(int index) throws IOException {
+        try {
+            im.assignInstance("client" + index, clazz, index + " " + params, 1);
+        } catch (Exception e) {
+            throw new IOException(e.getMessage());
+        }
+    }
+    private void fakeStartClient(int index) {
+        fakeBaseClients[index].start();
+    }
+    public void stopClient(int index) throws IOException {
+        if (fakeMachines) {
+            fakeStopClient(index);
+        } else {
+            distributedStopClient(index);
+        }
+    }
+    private void distributedStopClient(int index) throws IOException {
+        try {
+            im.removeInstance("client"+index);
+        } catch (Exception e) {
+            throw new IOException(e.getMessage());
+        }
+    }
+    private void fakeStopClient(int index) {
+        fakeBaseClients[index].stop();
+    }
+    
+    static public void main(String args[]) {
+        JUnitCore.main(args);
+    }
+}
diff -uNr zookeeper-3.4.6/src/java/systest/org/apache/zookeeper/test/system/BaseSysTest.java.rej zookeeper-3.4.6-b/src/java/systest/org/apache/zookeeper/test/system/BaseSysTest.java.rej
--- zookeeper-3.4.6/src/java/systest/org/apache/zookeeper/test/system/BaseSysTest.java.rej	1970-01-01 04:00:00.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/systest/org/apache/zookeeper/test/system/BaseSysTest.java.rej	2016-12-26 10:45:28.000000000 +0400
@@ -0,0 +1,23 @@
+***************
+*** 149,160 ****
+          qps = new QuorumPeer[count];
+          qpsDirs = new File[count];
+          for(int i = 1; i <= count; i++) {
+-             InetSocketAddress peerAddress = new InetSocketAddress("127.0.0.1",
+-                     fakeBasePort + i);
+-             InetSocketAddress electionAddr = new InetSocketAddress("127.0.0.1",
+-                     serverCount + fakeBasePort + i);
+-             peers.put(Long.valueOf(i), new QuorumServer(i, peerAddress,
+-                     electionAddr));
+          }
+          StringBuilder sb = new StringBuilder();
+          for(int i = 0; i < count; i++) {
+--- 149,156 ----
+          qps = new QuorumPeer[count];
+          qpsDirs = new File[count];
+          for(int i = 1; i <= count; i++) {
++             peers.put(Long.valueOf(i), new QuorumServer(
++                 i, "127.0.0.1", fakeBasePort + i, serverCount + fakeBasePort + i, null));
+          }
+          StringBuilder sb = new StringBuilder();
+          for(int i = 0; i < count; i++) {
diff -uNr zookeeper-3.4.6/src/java/systest/org/apache/zookeeper/test/system/QuorumPeerInstance.java zookeeper-3.4.6-b/src/java/systest/org/apache/zookeeper/test/system/QuorumPeerInstance.java
--- zookeeper-3.4.6/src/java/systest/org/apache/zookeeper/test/system/QuorumPeerInstance.java	2014-02-20 14:14:09.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/systest/org/apache/zookeeper/test/system/QuorumPeerInstance.java	2016-12-26 10:45:28.000000000 +0400
@@ -155,7 +155,7 @@
             peers = new HashMap<Long,QuorumServer>();
             for(int i = 0; i < parts.length; i++) {
                 String subparts[] = parts[i].split(":");
-                peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(subparts[0], Integer.parseInt(subparts[1]))));
+                peers.put(Long.valueOf(i), new QuorumServer(i, subparts[0], Integer.parseInt(subparts[1]), 0, null));
             }
             try {
                 if (LOG.isDebugEnabled()) {
diff -uNr zookeeper-3.4.6/src/java/systest/org/apache/zookeeper/test/system/QuorumPeerInstance.java.orig zookeeper-3.4.6-b/src/java/systest/org/apache/zookeeper/test/system/QuorumPeerInstance.java.orig
--- zookeeper-3.4.6/src/java/systest/org/apache/zookeeper/test/system/QuorumPeerInstance.java.orig	1970-01-01 04:00:00.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/systest/org/apache/zookeeper/test/system/QuorumPeerInstance.java.orig	2014-02-20 14:14:09.000000000 +0400
@@ -0,0 +1,276 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.test.system;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.util.HashMap;
+import java.util.Properties;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.server.quorum.QuorumPeer;
+import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;
+
+class QuorumPeerInstance implements Instance {
+    final private static Logger LOG = LoggerFactory.getLogger(QuorumPeerInstance.class);
+    private static final int syncLimit = 3;
+    private static final int initLimit = 3;
+    private static final int tickTime = 2000;
+    String serverHostPort;
+    int serverId;
+    Reporter r;
+    QuorumPeer peer;
+
+    public void setReporter(Reporter r) {
+        this.r = r;
+    }
+
+    InetSocketAddress clientAddr;
+    InetSocketAddress quorumAddr;
+    HashMap<Long, QuorumServer> peers;
+    File snapDir, logDir;
+
+    public QuorumPeerInstance() {
+        try {
+            File tmpFile = File.createTempFile("test", ".dir");
+            File tmpDir = tmpFile.getParentFile();
+            tmpFile.delete();
+            File zkDirs = new File(tmpDir, "zktmp.cfg");
+            logDir = tmpDir;
+            snapDir = tmpDir;
+            Properties p;
+            if (zkDirs.exists()) {
+                p = new Properties();
+                p.load(new FileInputStream(zkDirs));
+            } else {
+                p = System.getProperties();
+            }
+            logDir = new File(p.getProperty("logDir", tmpDir.getAbsolutePath()));
+            snapDir = new File(p.getProperty("snapDir", tmpDir.getAbsolutePath()));
+            logDir = File.createTempFile("zktst", ".dir", logDir);
+            logDir.delete();
+            logDir.mkdirs();
+            snapDir = File.createTempFile("zktst", ".dir", snapDir);
+            snapDir.delete();
+            snapDir.mkdirs();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void configure(String params) {
+        if (clientAddr == null) {
+            String parts[] = params.split(" ");
+            // The first time we are configured, it is just to tell
+            // us which machine we are
+            serverId = Integer.parseInt(parts[0]);
+            if (LOG.isDebugEnabled()) {
+                LOG.info("Setting up server " + serverId);
+            }
+            if (parts.length > 1 && parts[1].equals("false")) {
+                System.setProperty("zookeeper.leaderServes", "no");
+            } else {
+                System.setProperty("zookeeper.leaderServes", "yes");
+            }
+            // Let's grab two ports
+            try {
+                ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());
+                clientAddr = (InetSocketAddress) ss.getLocalSocketAddress();
+                ss.close();
+            } catch(IOException e) {
+                e.printStackTrace();
+            }
+            try {
+                ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());
+                quorumAddr = (InetSocketAddress) ss.getLocalSocketAddress();
+                ss.close();
+            } catch(IOException e) {
+                e.printStackTrace();
+            }
+            String report = clientAddr.getHostName() + ':' + clientAddr.getPort() +
+            ',' + quorumAddr.getHostName() + ':' + quorumAddr.getPort();
+            try {
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug("Reporting " + report);
+                }
+                r.report(report);
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+            return;
+        } else {
+            int spaceIndex = params.indexOf(' ');
+            if (spaceIndex == -1) {
+                LOG.warn("looking for host:port,... start|stop, but found " + params);
+                return;
+            }
+            String quorumSpecs = params.substring(0, spaceIndex);
+            String cmd = params.substring(spaceIndex+1);
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("Running command: " + cmd);
+            }
+            if (!cmd.equals("start")) {
+                if (peer != null) {
+                    peer.shutdown();
+                }
+                peer = null;
+                try {
+                    for(int i = 0; i < 5; i++) {
+                        Thread.sleep(500);
+                        try {
+                            // Wait until we can't connect
+                            new Socket("127.0.0.1", clientAddr.getPort()).close();
+                        } catch(IOException e) { break; }
+                    }
+                    r.report("stopped");
+                } catch (Exception e) {
+                    LOG.error("Unhandled error", e);
+                }
+                return;
+            }
+            String parts[] = quorumSpecs.split(",");
+            peers = new HashMap<Long,QuorumServer>();
+            for(int i = 0; i < parts.length; i++) {
+                String subparts[] = parts[i].split(":");
+                peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(subparts[0], Integer.parseInt(subparts[1]))));
+            }
+            try {
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug("Starting quorumPeer " + serverId + " on port " + clientAddr.getPort());
+                }
+                if (peer != null) {
+                    LOG.warn("Peer " + serverId + " already started");
+                    return;
+                }
+                System.err.println("SnapDir = " + snapDir + " LogDir = " + logDir);
+                peer = new QuorumPeer(peers, snapDir, logDir, clientAddr.getPort(), 0, serverId, tickTime, initLimit, syncLimit);
+                peer.start();
+                for(int i = 0; i < 5; i++) {
+                    Thread.sleep(500);
+                    try {
+                        // Wait until we can connect
+                        new Socket("127.0.0.1", clientAddr.getPort()).close();
+                        break;
+                    } catch(IOException e) {}
+                }
+                r.report("started");
+            } catch (Exception e) {
+                LOG.error("Unhandled exception", e);
+            }
+        }
+    }
+
+    public void start() {
+    }
+
+    static private void recursiveDelete(File dir) {
+        if (!dir.isDirectory()) {
+            dir.delete();
+            return;
+        }
+        for(File f: dir.listFiles()) {
+            recursiveDelete(f);
+        }
+        dir.delete();
+    }
+    
+    public void stop() {
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("Stopping peer " + serverId);
+        }
+        if (peer != null) {
+            peer.shutdown();
+        }
+        if (logDir != null) {
+            recursiveDelete(logDir);
+        }
+        if (snapDir != null) {
+            recursiveDelete(snapDir);
+        }
+    }
+
+    /**
+     * This method is used to configure a QuorumPeerInstance
+     * 
+     * @param im the InstanceManager that will be managing the new instance
+     * @param i the server number to configure (should be zero based)
+     * @throws NoAvailableContainers
+     * @throws DuplicateNameException
+     * @throws InterruptedException
+     * @throws KeeperException
+     */
+    public static String[] createServer(InstanceManager im, int i) throws NoAvailableContainers, DuplicateNameException, InterruptedException, KeeperException {
+        return createServer(im, i, true);
+    }
+    
+    /**
+     * This method is used to configure a QuorumPeerInstance
+     * 
+     * @param im the InstanceManager that will be managing the new instance
+     * @param i the server number to configure (should be zero based)
+     * @param leaderServes if false, the leader will not accept client connections
+     * @throws NoAvailableContainers
+     * @throws DuplicateNameException
+     * @throws InterruptedException
+     * @throws KeeperException
+     */
+    public static String[] createServer(InstanceManager im, int i, boolean leaderServes) throws NoAvailableContainers, DuplicateNameException, InterruptedException, KeeperException {
+        im.assignInstance("server"+i, QuorumPeerInstance.class, Integer.toString(i) + " " + leaderServes, 50);
+        return im.getStatus("server"+i, 3000).split(",");
+        
+    }
+
+    /**
+     * Start an instance of the quorumPeer.
+     * @param im the manager of the instance
+     * @param quorumHostPort the comma-separated list of host:port pairs of quorum peers 
+     * @param index the zero based index of the server to start.
+     * @throws InterruptedException
+     * @throws KeeperException
+     * @throws NoAssignmentException
+     */
+    public static void startInstance(InstanceManager im, String quorumHostPort, int index) throws InterruptedException, KeeperException, NoAssignmentException {
+        im.resetStatus("server" + index);
+        im.reconfigureInstance("server"+index, quorumHostPort + " start");
+        im.getStatus("server" + index, 5000);
+    }
+
+    /**
+     * Stop an instance of the quorumPeer
+     * @param im the manager of the instance
+     * @param index the zero based index fo the server to stop
+     * @throws InterruptedException
+     * @throws KeeperException
+     * @throws NoAssignmentException
+     */
+    public static void stopInstance(InstanceManager im, int index) throws InterruptedException, KeeperException, NoAssignmentException {
+        im.resetStatus("server" + index);
+        im.reconfigureInstance("server"+index, Integer.toString(index) + " stop");
+        im.getStatus("server" + index, 3000);
+   
+    }
+
+}
diff -uNr zookeeper-3.4.6/src/java/test/org/apache/zookeeper/server/quorum/CnxManagerTest.java zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/server/quorum/CnxManagerTest.java
--- zookeeper-3.4.6/src/java/test/org/apache/zookeeper/server/quorum/CnxManagerTest.java	2014-02-20 14:14:10.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/server/quorum/CnxManagerTest.java	2016-12-26 10:45:28.000000000 +0400
@@ -66,9 +66,9 @@
             peerQuorumPort[i] = PortAssignment.unique();
             peerClientPort[i] = PortAssignment.unique();
             peers.put(Long.valueOf(i),
-                    new QuorumServer(i,
-                            new InetSocketAddress(peerQuorumPort[i]),
-                    new InetSocketAddress(PortAssignment.unique())));
+                      new QuorumServer(i, "0.0.0.0",
+                                       peerQuorumPort[i],
+                                       PortAssignment.unique(), null));
             peerTmpdir[i] = ClientBase.createTmpDir();
         }
     }
@@ -164,15 +164,14 @@
     public void testCnxManagerTimeout() throws Exception {
         Random rand = new Random();
         byte b = (byte) rand.nextInt();
+        int finalOctet = b & 0xFF;
         int deadPort = PortAssignment.unique();
-        String deadAddress = new String("10.1.1." + b);
+        String deadAddress = new String("192.0.2." + finalOctet);
             
         LOG.info("This is the dead address I'm trying: " + deadAddress);
             
         peers.put(Long.valueOf(2),
-                new QuorumServer(2,
-                        new InetSocketAddress(deadAddress, deadPort),
-                        new InetSocketAddress(deadAddress, PortAssignment.unique())));
+                  new QuorumServer(2, deadAddress, deadPort, PortAssignment.unique(), null));
         peerTmpdir[2] = ClientBase.createTmpDir();
     
         QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2);
diff -uNr zookeeper-3.4.6/src/java/test/org/apache/zookeeper/server/quorum/FLEBackwardElectionRoundTest.java zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/server/quorum/FLEBackwardElectionRoundTest.java
--- zookeeper-3.4.6/src/java/test/org/apache/zookeeper/server/quorum/FLEBackwardElectionRoundTest.java	2014-02-20 14:14:10.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/server/quorum/FLEBackwardElectionRoundTest.java	2016-12-26 10:45:28.000000000 +0400
@@ -93,9 +93,8 @@
         for(int i = 0; i < count; i++) {
             int clientport = PortAssignment.unique();
             peers.put(Long.valueOf(i),
-                    new QuorumServer(i,
-                            new InetSocketAddress(clientport),
-                            new InetSocketAddress(PortAssignment.unique())));
+                      new QuorumServer(i, "0.0.0.0", clientport,
+                                       PortAssignment.unique(), null));
             tmpdir[i] = ClientBase.createTmpDir();
             port[i] = clientport;
         }
diff -uNr zookeeper-3.4.6/src/java/test/org/apache/zookeeper/server/quorum/FLECompatibilityTest.java zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/server/quorum/FLECompatibilityTest.java
--- zookeeper-3.4.6/src/java/test/org/apache/zookeeper/server/quorum/FLECompatibilityTest.java	2014-02-20 14:14:10.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/server/quorum/FLECompatibilityTest.java	2016-12-26 10:45:28.000000000 +0400
@@ -273,9 +273,9 @@
     throws Exception {
         for (int i = 0; i < count; i++) {
             peers.put(Long.valueOf(i),
-                    new QuorumServer(i,
-                            new InetSocketAddress(PortAssignment.unique()),
-                    new InetSocketAddress(PortAssignment.unique())));
+                      new QuorumServer(i, "0.0.0.0",
+                                       PortAssignment.unique(),
+                                       PortAssignment.unique(), null));
             tmpdir[i] = ClientBase.createTmpDir();
             port[i] = PortAssignment.unique();
         }
diff -uNr zookeeper-3.4.6/src/java/test/org/apache/zookeeper/server/quorum/FLEDontCareTest.java zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/server/quorum/FLEDontCareTest.java
--- zookeeper-3.4.6/src/java/test/org/apache/zookeeper/server/quorum/FLEDontCareTest.java	2014-02-20 14:14:10.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/server/quorum/FLEDontCareTest.java	2016-12-26 10:45:28.000000000 +0400
@@ -74,8 +74,7 @@
         peers = new HashMap<Long,QuorumServer>();
         for(int i = 0; i < 5; i++) {
             peers.put(Long.valueOf(i),
-                    new QuorumServer(Long.valueOf(i),
-                            new InetSocketAddress("127.0.0.1", PortAssignment.unique())));
+                      new QuorumServer(Long.valueOf(i), "127.0.0.1", PortAssignment.unique(), 0, null));
         }
         peer = new QuorumPeer(peers,
                 tmpdir,
diff -uNr zookeeper-3.4.6/src/java/test/org/apache/zookeeper/server/quorum/FLELostMessageTest.java zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/server/quorum/FLELostMessageTest.java
--- zookeeper-3.4.6/src/java/test/org/apache/zookeeper/server/quorum/FLELostMessageTest.java	2014-02-20 14:14:10.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/server/quorum/FLELostMessageTest.java	2016-12-26 10:45:28.000000000 +0400
@@ -71,9 +71,8 @@
         for(int i = 0; i < count; i++) {
             int clientport = PortAssignment.unique();
             peers.put(Long.valueOf(i),
-                    new QuorumServer(i,
-                            new InetSocketAddress(clientport),
-                            new InetSocketAddress(PortAssignment.unique())));
+                      new QuorumServer(i, "0.0.0.0", clientport,
+                                       PortAssignment.unique(), null));
             tmpdir[i] = ClientBase.createTmpDir();
             port[i] = clientport;
         }
diff -uNr zookeeper-3.4.6/src/java/test/org/apache/zookeeper/server/quorum/Zab1_0Test.java zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/server/quorum/Zab1_0Test.java
--- zookeeper-3.4.6/src/java/test/org/apache/zookeeper/server/quorum/Zab1_0Test.java	2014-02-20 14:14:10.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/server/quorum/Zab1_0Test.java	2016-12-26 10:45:28.000000000 +0400
@@ -1391,8 +1391,8 @@
         peer.initLimit = 2;
         peer.tickTime = 2000;
         peer.quorumPeers = new HashMap<Long, QuorumServer>();
-        peer.quorumPeers.put(1L, new QuorumServer(0, new InetSocketAddress(33221)));
-        peer.quorumPeers.put(1L, new QuorumServer(1, new InetSocketAddress(33223)));
+        peer.quorumPeers.put(1L, new QuorumServer(0, "0.0.0.0", 33221, 0, null));
+        peer.quorumPeers.put(1L, new QuorumServer(1, "0.0.0.0", 33223, 0, null));
         peer.setQuorumVerifier(new QuorumMaj(3));
         peer.setCnxnFactory(new NullServerCnxnFactory());
         File version2 = new File(tmpDir, "version-2");
diff -uNr zookeeper-3.4.6/src/java/test/org/apache/zookeeper/server/quorum/Zab1_0Test.java.orig zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/server/quorum/Zab1_0Test.java.orig
--- zookeeper-3.4.6/src/java/test/org/apache/zookeeper/server/quorum/Zab1_0Test.java.orig	1970-01-01 04:00:00.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/server/quorum/Zab1_0Test.java.orig	2014-02-20 14:14:10.000000000 +0400
@@ -0,0 +1,1451 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server.quorum;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.BufferedReader;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.EOFException;
+import java.lang.reflect.Field;
+import java.net.InetSocketAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+import org.apache.jute.BinaryInputArchive;
+import org.apache.jute.BinaryOutputArchive;
+import org.apache.jute.InputArchive;
+import org.apache.jute.OutputArchive;
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.PortAssignment;
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.Watcher.Event.EventType;
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.ZooDefs.Ids;
+import org.apache.zookeeper.ZooKeeper.States;
+import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.server.ByteBufferInputStream;
+import org.apache.zookeeper.server.ByteBufferOutputStream;
+import org.apache.zookeeper.server.Request;
+import org.apache.zookeeper.server.ServerCnxn;
+import org.apache.zookeeper.server.ServerCnxnFactory;
+import org.apache.zookeeper.server.SyncRequestProcessor;
+import org.apache.zookeeper.server.ZKDatabase;
+import org.apache.zookeeper.server.ZooKeeperServer;
+import org.apache.zookeeper.server.ZooKeeperServer.DataTreeBuilder;
+import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
+import org.apache.zookeeper.server.persistence.Util;
+import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;
+import org.apache.zookeeper.server.quorum.flexible.QuorumMaj;
+import org.apache.zookeeper.server.util.ZxidUtils;
+import org.apache.zookeeper.txn.CreateSessionTxn;
+import org.apache.zookeeper.txn.CreateTxn;
+import org.apache.zookeeper.txn.ErrorTxn;
+import org.apache.zookeeper.txn.SetDataTxn;
+import org.apache.zookeeper.txn.TxnHeader;
+import org.junit.Assert;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class Zab1_0Test {
+    private static final int SYNC_LIMIT = 2;
+
+    private static final Logger LOG = LoggerFactory.getLogger(Zab1_0Test.class);
+
+    private static final class LeadThread extends Thread {
+        private final Leader leader;
+
+        private LeadThread(Leader leader) {
+            this.leader = leader;
+        }
+
+        public void run() {
+            try {
+                leader.lead();
+            } catch (InterruptedException e) {
+                LOG.info("Leader thread interrupted", e);
+            } catch (Exception e) {
+                LOG.warn("Unexpected exception in leader thread", e);
+            } finally {
+                leader.shutdown("lead ended");
+            }
+        }
+    }
+           
+    private static final class MockLeader extends Leader {
+           
+        MockLeader(QuorumPeer qp, LeaderZooKeeperServer zk)
+        throws IOException {
+            super(qp, zk);
+        }
+           
+        /**
+         * This method returns the value of the variable that holds the epoch
+         * to be proposed and that has been proposed, depending on the point
+         * of the execution in which it is called. 
+         * 
+         * @return epoch
+         */
+        public long getCurrentEpochToPropose() {
+            return epoch;
+        }
+    }
+     
+   public static final class FollowerMockThread extends Thread {
+    	private final Leader leader;
+    	private final long followerSid;
+    	public long epoch = -1;
+    	public String msg = null;
+    	private boolean onlyGetEpochToPropose;
+    	
+    	private FollowerMockThread(long followerSid, Leader leader, boolean onlyGetEpochToPropose) {
+            this.leader = leader;
+            this.followerSid = followerSid;
+            this.onlyGetEpochToPropose = onlyGetEpochToPropose;
+        }
+
+        public void run() {
+            if (onlyGetEpochToPropose) {
+	            try {
+	            	epoch = leader.getEpochToPropose(followerSid, 0);
+	            } catch (Exception e) {
+	            }
+            } else {	            
+	            try{
+	                leader.waitForEpochAck(followerSid, new StateSummary(0, 0)); 
+	                msg = "FollowerMockThread (id = " + followerSid + ")  returned from waitForEpochAck";      
+	            } catch (Exception e) {	            	
+	            }
+            }
+        }       
+    }
+    @Test
+    public void testLeaderInConnectingFollowers() throws Exception {    
+        File tmpDir = File.createTempFile("test", "dir");
+        tmpDir.delete();
+        tmpDir.mkdir();
+        Leader leader = null;
+        try {
+            QuorumPeer peer = createQuorumPeer(tmpDir);
+            leader = createLeader(tmpDir, peer);
+            peer.leader = leader;
+            peer.setAcceptedEpoch(5);
+            
+            FollowerMockThread f1 = new FollowerMockThread(1, leader, true);
+            FollowerMockThread f2 = new FollowerMockThread(2, leader, true);
+            f1.start();
+            f2.start();
+            
+            // wait until followers time out in getEpochToPropose - they shouldn't return
+            // normally because the leader didn't execute getEpochToPropose and so its epoch was not
+            // accounted for
+            f1.join(leader.self.getInitLimit()*leader.self.getTickTime() + 5000);
+            f2.join(leader.self.getInitLimit()*leader.self.getTickTime() + 5000);
+                
+            // even though followers timed out, their ids are in connectingFollowers, and their
+            // epoch were accounted for, so the leader should not block and since it started with 
+            // accepted epoch = 5 it should now have 6
+            try {
+            	long epoch = leader.getEpochToPropose(leader.self.getId(), leader.self.getAcceptedEpoch());
+            	Assert.assertEquals("leader got wrong epoch from getEpochToPropose", 6, epoch);	
+            } catch (Exception e){ 
+            	Assert.fail("leader timed out in getEpochToPropose");
+            }
+        } finally {
+            if (leader != null) {
+                leader.shutdown("end of test");
+            }
+            recursiveDelete(tmpDir);
+        }
+    }
+    
+    /**
+     * In this test, the leader sets the last accepted epoch to 5. The call
+     * to getEpochToPropose should set epoch to 6 and wait until another 
+     * follower executes it. If in getEpochToPropose we don't check if
+     * lastAcceptedEpoch == epoch, then the call from the subsequent
+     * follower with lastAcceptedEpoch = 6 doesn't change the value
+     * of epoch, and the test fails. It passes with the fix to predicate.
+     * 
+     * {@link https://issues.apache.org/jira/browse/ZOOKEEPER-1343}
+     * 
+     * 
+     * @throws Exception
+     */
+        
+    @Test
+    public void testLastAcceptedEpoch() throws Exception {    
+        File tmpDir = File.createTempFile("test", "dir");
+        tmpDir.delete();
+        tmpDir.mkdir();
+        Leader leader = null;
+        LeadThread leadThread = null;
+        try {
+            QuorumPeer peer = createQuorumPeer(tmpDir);
+            leader = createMockLeader(tmpDir, peer);
+            peer.leader = leader;
+            peer.setAcceptedEpoch(5);
+            leadThread = new LeadThread(leader); 
+            leadThread.start();
+            
+            while(((MockLeader) leader).getCurrentEpochToPropose() != 6){
+                Thread.sleep(20);
+            }
+                
+            try {
+                long epoch = leader.getEpochToPropose(1, 6);
+                Assert.assertEquals("New proposed epoch is wrong", 7, epoch);  
+            } catch (Exception e){ 
+                Assert.fail("Timed out in getEpochToPropose");
+            }
+            
+        } finally {
+            if (leader != null) {
+                leader.shutdown("end of test");
+            }
+            if (leadThread != null) {
+                leadThread.interrupt();
+                leadThread.join();
+            }
+            recursiveDelete(tmpDir);
+        }
+    }
+        
+    @Test
+    public void testLeaderInElectingFollowers() throws Exception {    
+        File tmpDir = File.createTempFile("test", "dir");
+        tmpDir.delete();
+        tmpDir.mkdir();
+        Leader leader = null;
+        try {
+            QuorumPeer peer = createQuorumPeer(tmpDir);
+            leader = createLeader(tmpDir, peer);
+            peer.leader = leader;            
+            
+            FollowerMockThread f1 = new FollowerMockThread(1, leader, false);
+            FollowerMockThread f2 = new FollowerMockThread(2, leader, false);
+
+            // things needed for waitForEpochAck to run (usually in leader.lead(), but we're not running leader here)
+            leader.readyToStart = true;
+            leader.leaderStateSummary = new StateSummary(leader.self.getCurrentEpoch(), leader.zk.getLastProcessedZxid());
+            
+            f1.start();
+            f2.start();         
+            
+            // wait until followers time out in waitForEpochAck - they shouldn't return
+            // normally because the leader didn't execute waitForEpochAck
+            f1.join(leader.self.getInitLimit()*leader.self.getTickTime() + 5000);
+            f2.join(leader.self.getInitLimit()*leader.self.getTickTime() + 5000);
+                        
+            // make sure that they timed out and didn't return normally  
+            Assert.assertTrue(f1.msg + " without waiting for leader", f1.msg == null);            
+            Assert.assertTrue(f2.msg + " without waiting for leader", f2.msg == null);
+        } finally {
+            if (leader != null) {
+                leader.shutdown("end of test");
+            }
+            recursiveDelete(tmpDir);
+        }
+    }
+
+    private static final class NullServerCnxnFactory extends ServerCnxnFactory {
+        public void startup(ZooKeeperServer zkServer) throws IOException,
+                InterruptedException {
+        }
+        public void start() {
+        }
+        public void shutdown() {
+        }
+        public void setMaxClientCnxnsPerHost(int max) {
+        }
+        public void join() throws InterruptedException {
+        }
+        public int getMaxClientCnxnsPerHost() {
+            return 0;
+        }
+        public int getLocalPort() {
+            return 0;
+        }
+        public InetSocketAddress getLocalAddress() {
+            return null;
+        }
+        public Iterable<ServerCnxn> getConnections() {
+            return null;
+        }
+        public void configure(InetSocketAddress addr, int maxClientCnxns)
+                throws IOException {
+        }
+        public void closeSession(long sessionId) {
+        }
+        public void closeAll() {
+        }
+        @Override
+        public int getNumAliveConnections() {
+            return 0;
+        }
+    }
+    static Socket[] getSocketPair() throws IOException {
+        ServerSocket ss = new ServerSocket();
+        ss.bind(null);
+        InetSocketAddress endPoint = (InetSocketAddress) ss.getLocalSocketAddress();
+        Socket s = new Socket(endPoint.getAddress(), endPoint.getPort());
+        return new Socket[] { s, ss.accept() };
+    }
+    static void readPacketSkippingPing(InputArchive ia, QuorumPacket qp) throws IOException {
+        while(true) {
+            ia.readRecord(qp, null);
+            if (qp.getType() != Leader.PING) {
+                return;
+            }
+        }
+    }
+    
+    static public interface LeaderConversation {
+        void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws Exception;
+    }
+    
+    static public interface PopulatedLeaderConversation {
+        void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l, long zxid) throws Exception;
+    }
+    
+    static public interface FollowerConversation {
+        void converseWithFollower(InputArchive ia, OutputArchive oa, Follower f) throws Exception;
+    }
+    
+    static public interface ObserverConversation {
+        void converseWithObserver(InputArchive ia, OutputArchive oa, Observer o) throws Exception;
+    }
+
+    public void testLeaderConversation(LeaderConversation conversation) throws Exception {
+        Socket pair[] = getSocketPair();
+        Socket leaderSocket = pair[0];
+        Socket followerSocket = pair[1];
+        File tmpDir = File.createTempFile("test", "dir");
+        tmpDir.delete();
+        tmpDir.mkdir();
+        LeadThread leadThread = null;
+        Leader leader = null;
+        try {
+            QuorumPeer peer = createQuorumPeer(tmpDir);
+            leader = createLeader(tmpDir, peer);
+            peer.leader = leader;
+            leadThread = new LeadThread(leader);
+            leadThread.start();
+
+            while(!leader.readyToStart) {
+                Thread.sleep(20);
+            }
+            
+            LearnerHandler lh = new LearnerHandler(leaderSocket, leader);
+            lh.start();
+            leaderSocket.setSoTimeout(4000);
+
+            InputArchive ia = BinaryInputArchive.getArchive(followerSocket
+                    .getInputStream());
+            OutputArchive oa = BinaryOutputArchive.getArchive(followerSocket
+                    .getOutputStream());
+
+            conversation.converseWithLeader(ia, oa, leader);
+        } finally {
+            if (leader != null) {
+                leader.shutdown("end of test");
+            }
+            if (leadThread != null) {
+                leadThread.interrupt();
+                leadThread.join();
+            }
+            recursiveDelete(tmpDir);
+        }
+    }
+    
+    public void testPopulatedLeaderConversation(PopulatedLeaderConversation conversation, int ops) throws Exception {
+        Socket pair[] = getSocketPair();
+        Socket leaderSocket = pair[0];
+        Socket followerSocket = pair[1];
+        File tmpDir = File.createTempFile("test", "dir");
+        tmpDir.delete();
+        tmpDir.mkdir();
+        LeadThread leadThread = null;
+        Leader leader = null;
+        try {              
+            // Setup a database with two znodes
+            FileTxnSnapLog snapLog = new FileTxnSnapLog(tmpDir, tmpDir);
+            ZKDatabase zkDb = new ZKDatabase(snapLog);
+            
+            Assert.assertTrue(ops >= 1);
+            long zxid = ZxidUtils.makeZxid(1, 0);            
+            for(int i = 1; i <= ops; i++){
+                zxid = ZxidUtils.makeZxid(1, i);
+                String path = "/foo-"+ i;
+                zkDb.processTxn(new TxnHeader(13,1000+i,zxid,30+i,ZooDefs.OpCode.create), 
+                                                new CreateTxn(path, "fpjwasalsohere".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));
+                Stat stat = new Stat();
+                Assert.assertEquals("fpjwasalsohere", new String(zkDb.getData(path, stat, null)));
+            }                
+            Assert.assertTrue(zxid > ZxidUtils.makeZxid(1, 0));
+            
+            // Generate snapshot and close files.
+            snapLog.save(zkDb.getDataTree(), zkDb.getSessionWithTimeOuts());
+            snapLog.close();
+            
+            QuorumPeer peer = createQuorumPeer(tmpDir);
+                        
+            leader = createLeader(tmpDir, peer);
+            peer.leader = leader;
+            
+            // Set the last accepted epoch and current epochs to be 1
+            peer.setAcceptedEpoch(1);
+            peer.setCurrentEpoch(1);
+
+            
+            leadThread = new LeadThread(leader);
+            leadThread.start();
+
+            while(leader.cnxAcceptor == null || !leader.cnxAcceptor.isAlive()) {
+                Thread.sleep(20);
+            }
+            
+            LearnerHandler lh = new LearnerHandler(leaderSocket, leader);
+            lh.start();
+            leaderSocket.setSoTimeout(4000);
+
+            InputArchive ia = BinaryInputArchive.getArchive(followerSocket
+                    .getInputStream());
+            OutputArchive oa = BinaryOutputArchive.getArchive(followerSocket
+                    .getOutputStream());
+
+            conversation.converseWithLeader(ia, oa, leader, zxid);
+        } finally {
+            if (leader != null) {
+                leader.shutdown("end of test");
+            }
+            if (leadThread != null) {
+                leadThread.interrupt();
+                leadThread.join();
+            }
+            recursiveDelete(tmpDir);
+        }
+    }
+    
+    
+    public void testFollowerConversation(FollowerConversation conversation) throws Exception {
+        File tmpDir = File.createTempFile("test", "dir");
+        tmpDir.delete();
+        tmpDir.mkdir();
+        Thread followerThread = null;
+        ConversableFollower follower = null;
+        QuorumPeer peer = null;
+        try {
+            peer = createQuorumPeer(tmpDir);
+            follower = createFollower(tmpDir, peer);
+            peer.follower = follower;
+            
+            ServerSocket ss = new ServerSocket();
+            ss.bind(null);
+            follower.setLeaderSocketAddress((InetSocketAddress)ss.getLocalSocketAddress());
+            final Follower followerForThread = follower;
+            
+            followerThread = new Thread() {
+                public void run() {
+                    try {
+                        followerForThread.followLeader();
+                    } catch (InterruptedException e) {
+                        LOG.info("Follower thread interrupted", e);
+                    } catch (Exception e) {
+                        LOG.warn("Unexpected exception in follower thread", e);
+                    }
+                }
+            };
+            followerThread.start();
+            Socket leaderSocket = ss.accept();
+            
+            InputArchive ia = BinaryInputArchive.getArchive(leaderSocket
+                    .getInputStream());
+            OutputArchive oa = BinaryOutputArchive.getArchive(leaderSocket
+                    .getOutputStream());
+
+            conversation.converseWithFollower(ia, oa, follower);
+        } finally {
+            if (follower != null) {
+                follower.shutdown();
+            }
+            if (followerThread != null) {
+                followerThread.interrupt();
+                followerThread.join();
+            }
+            if (peer != null) {
+                peer.shutdown();
+            }
+            recursiveDelete(tmpDir);
+        }
+    }
+
+    public void testObserverConversation(ObserverConversation conversation) throws Exception {
+        File tmpDir = File.createTempFile("test", "dir");
+        tmpDir.delete();
+        tmpDir.mkdir();
+        Thread observerThread = null;
+        ConversableObserver observer = null;
+        QuorumPeer peer = null;
+        try {
+            peer = createQuorumPeer(tmpDir);
+            peer.setSyncEnabled(true);
+            observer = createObserver(tmpDir, peer);
+            peer.observer = observer;
+
+            ServerSocket ss = new ServerSocket();
+            ss.bind(null);
+            observer.setLeaderSocketAddress((InetSocketAddress)ss.getLocalSocketAddress());
+            final Observer observerForThread = observer;
+
+            observerThread = new Thread() {
+                public void run() {
+                    try {
+                        observerForThread.observeLeader();
+                    } catch(Exception e) {
+                        e.printStackTrace();
+                    }
+                }
+            };
+            observerThread.start();
+            Socket leaderSocket = ss.accept();
+
+            InputArchive ia = BinaryInputArchive.getArchive(leaderSocket
+                    .getInputStream());
+            OutputArchive oa = BinaryOutputArchive.getArchive(leaderSocket
+                    .getOutputStream());
+
+            conversation.converseWithObserver(ia, oa, observer);
+        } finally {
+            if (observer != null) {
+                observer.shutdown();
+            }
+            if (observerThread != null) {
+                observerThread.interrupt();
+                observerThread.join();
+            }
+            if (peer != null) {
+                peer.shutdown();
+            }
+            recursiveDelete(tmpDir);
+        }
+    }
+
+    @Test
+    public void testUnnecessarySnap() throws Exception {
+        testPopulatedLeaderConversation(new PopulatedLeaderConversation() {
+           @Override
+           public void converseWithLeader(InputArchive ia, OutputArchive oa,
+                    Leader l, long zxid) throws Exception {
+               
+               Assert.assertEquals(1, l.self.getAcceptedEpoch());
+               Assert.assertEquals(1, l.self.getCurrentEpoch());
+               
+               /* we test a normal run. everything should work out well. */
+               LearnerInfo li = new LearnerInfo(1, 0x10000);
+               byte liBytes[] = new byte[12];
+               ByteBufferOutputStream.record2ByteBuffer(li,
+                       ByteBuffer.wrap(liBytes));
+               QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 1,
+                       liBytes, null);
+               oa.writeRecord(qp, null);
+               
+               readPacketSkippingPing(ia, qp);
+               Assert.assertEquals(Leader.LEADERINFO, qp.getType());
+               Assert.assertEquals(ZxidUtils.makeZxid(2, 0), qp.getZxid());
+               Assert.assertEquals(ByteBuffer.wrap(qp.getData()).getInt(),
+                       0x10000);
+               Assert.assertEquals(2, l.self.getAcceptedEpoch());
+               Assert.assertEquals(1, l.self.getCurrentEpoch());
+               
+               byte epochBytes[] = new byte[4];
+               final ByteBuffer wrappedEpochBytes = ByteBuffer.wrap(epochBytes);
+               wrappedEpochBytes.putInt(1);
+               qp = new QuorumPacket(Leader.ACKEPOCH, zxid, epochBytes, null);
+               oa.writeRecord(qp, null);
+               
+               readPacketSkippingPing(ia, qp);
+               Assert.assertEquals(Leader.DIFF, qp.getType());
+           
+           }
+       }, 2);
+    }
+
+    // We want to track the change with a callback rather than depending on timing
+    class TrackerWatcher implements Watcher {
+        boolean changed;
+        synchronized void waitForChange() throws InterruptedException {
+            while(!changed) {
+                wait();
+            }
+        }
+
+        @Override
+        public void process(WatchedEvent event) {
+            if (event.getType() == EventType.NodeDataChanged) {
+                synchronized(this) {
+                    changed = true;
+                    notifyAll();
+                }
+            }
+        }
+        synchronized public boolean changed() {
+            return changed;
+        } 
+    };
+
+
+    @Test
+    public void testNormalFollowerRun() throws Exception {
+        testFollowerConversation(new FollowerConversation() {
+            @Override
+            public void converseWithFollower(InputArchive ia, OutputArchive oa,
+                    Follower f) throws Exception {
+                File tmpDir = File.createTempFile("test", "dir");
+                tmpDir.delete();
+                tmpDir.mkdir();
+                File logDir = f.fzk.getTxnLogFactory().getDataDir().getParentFile();
+                File snapDir = f.fzk.getTxnLogFactory().getSnapDir().getParentFile();
+                try {
+                    Assert.assertEquals(0, f.self.getAcceptedEpoch());
+                    Assert.assertEquals(0, f.self.getCurrentEpoch());
+
+                    // Setup a database with a single /foo node
+                    ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));
+                    final long firstZxid = ZxidUtils.makeZxid(1, 1);
+                    zkDb.processTxn(new TxnHeader(13, 1313, firstZxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));
+                    Stat stat = new Stat();
+                    Assert.assertEquals("data1", new String(zkDb.getData("/foo", stat, null)));
+
+                    QuorumPacket qp = new QuorumPacket();
+                    readPacketSkippingPing(ia, qp);
+                    Assert.assertEquals(Leader.FOLLOWERINFO, qp.getType());
+                    Assert.assertEquals(qp.getZxid(), 0);
+                    LearnerInfo learnInfo = new LearnerInfo();
+                    ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);
+                    Assert.assertEquals(learnInfo.getProtocolVersion(), 0x10000);
+                    Assert.assertEquals(learnInfo.getServerid(), 0);
+                
+                    // We are simulating an established leader, so the epoch is 1
+                    qp.setType(Leader.LEADERINFO);
+                    qp.setZxid(ZxidUtils.makeZxid(1, 0));
+                    byte protoBytes[] = new byte[4];
+                    ByteBuffer.wrap(protoBytes).putInt(0x10000);
+                    qp.setData(protoBytes);
+                    oa.writeRecord(qp, null);
+                
+                    readPacketSkippingPing(ia, qp);
+                    Assert.assertEquals(Leader.ACKEPOCH, qp.getType());
+                    Assert.assertEquals(0, qp.getZxid());
+                    Assert.assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());
+                    Assert.assertEquals(1, f.self.getAcceptedEpoch());
+                    Assert.assertEquals(0, f.self.getCurrentEpoch());
+                    
+                    // Send the snapshot we created earlier
+                    qp.setType(Leader.SNAP);
+                    qp.setData(new byte[0]);
+                    qp.setZxid(zkDb.getDataTreeLastProcessedZxid());
+                    oa.writeRecord(qp, null);
+                    zkDb.serializeSnapshot(oa);
+                    oa.writeString("BenWasHere", null);
+                    qp.setType(Leader.NEWLEADER);
+                    qp.setZxid(ZxidUtils.makeZxid(1, 0));
+                    oa.writeRecord(qp, null);
+
+                    // Get the ack of the new leader
+                    readPacketSkippingPing(ia, qp);
+                    Assert.assertEquals(Leader.ACK, qp.getType());
+                    Assert.assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());
+                    Assert.assertEquals(1, f.self.getAcceptedEpoch());
+                    Assert.assertEquals(1, f.self.getCurrentEpoch());
+                    
+                    Assert.assertEquals(firstZxid, f.fzk.getLastProcessedZxid());
+                    
+                    // Make sure the data was recorded in the filesystem ok
+                    ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));
+                    long lastZxid = zkDb2.loadDataBase();
+                    Assert.assertEquals("data1", new String(zkDb2.getData("/foo", stat, null)));
+                    Assert.assertEquals(firstZxid, lastZxid);
+
+                    // Propose an update
+                    long proposalZxid = ZxidUtils.makeZxid(1, 1000);
+                    proposeSetData(qp, proposalZxid, "data2", 2);
+                    oa.writeRecord(qp, null);
+                    
+                    TrackerWatcher watcher = new TrackerWatcher();
+                    
+                    // The change should not have happened yet, since we haven't committed
+                    Assert.assertEquals("data1", new String(f.fzk.getZKDatabase().getData("/foo", stat, watcher)));
+                    
+                    // The change should happen now
+                    qp.setType(Leader.COMMIT);
+                    qp.setZxid(proposalZxid);
+                    oa.writeRecord(qp, null);
+                    
+                    qp.setType(Leader.UPTODATE);
+                    qp.setZxid(0);
+                    oa.writeRecord(qp, null);
+                    
+                    // Read the uptodate ack
+                    readPacketSkippingPing(ia, qp);
+                    Assert.assertEquals(Leader.ACK, qp.getType());
+                    Assert.assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());
+                    
+                    readPacketSkippingPing(ia, qp);
+                    Assert.assertEquals(Leader.ACK, qp.getType());
+                    Assert.assertEquals(proposalZxid, qp.getZxid());
+                    
+                    watcher.waitForChange();
+                    Assert.assertEquals("data2", new String(f.fzk.getZKDatabase().getData("/foo", stat, null)));
+                    
+                    // check and make sure the change is persisted
+                    zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));
+                    lastZxid = zkDb2.loadDataBase();
+                    Assert.assertEquals("data2", new String(zkDb2.getData("/foo", stat, null)));
+                    Assert.assertEquals(proposalZxid, lastZxid);
+                } finally {
+                    recursiveDelete(tmpDir);
+                }
+                
+            }
+
+            private void proposeSetData(QuorumPacket qp, long zxid, String data, int version) throws IOException {
+                qp.setType(Leader.PROPOSAL);
+                qp.setZxid(zxid);
+                TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55, ZooDefs.OpCode.setData);
+                SetDataTxn sdt = new SetDataTxn("/foo", data.getBytes(), version);
+                ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                OutputArchive boa = BinaryOutputArchive.getArchive(baos);
+                boa.writeRecord(hdr, null);
+                boa.writeRecord(sdt, null);
+                qp.setData(baos.toByteArray());
+            }
+        });
+    }
+    
+    @Test
+    public void testNormalFollowerRunWithDiff() throws Exception {
+        testFollowerConversation(new FollowerConversation() {
+            @Override
+            public void converseWithFollower(InputArchive ia, OutputArchive oa,
+                    Follower f) throws Exception {
+                File tmpDir = File.createTempFile("test", "dir");
+                tmpDir.delete();
+                tmpDir.mkdir();
+                File logDir = f.fzk.getTxnLogFactory().getDataDir().getParentFile();
+                File snapDir = f.fzk.getTxnLogFactory().getSnapDir().getParentFile();
+                try {
+                    Assert.assertEquals(0, f.self.getAcceptedEpoch());
+                    Assert.assertEquals(0, f.self.getCurrentEpoch());
+
+                    // Setup a database with a single /foo node
+                    ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));
+                    final long firstZxid = ZxidUtils.makeZxid(1, 1);
+                    zkDb.processTxn(new TxnHeader(13, 1313, firstZxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));
+                    Stat stat = new Stat();
+                    Assert.assertEquals("data1", new String(zkDb.getData("/foo", stat, null)));
+
+                    QuorumPacket qp = new QuorumPacket();
+                    readPacketSkippingPing(ia, qp);
+                    Assert.assertEquals(Leader.FOLLOWERINFO, qp.getType());
+                    Assert.assertEquals(qp.getZxid(), 0);
+                    LearnerInfo learnInfo = new LearnerInfo();
+                    ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);
+                    Assert.assertEquals(learnInfo.getProtocolVersion(), 0x10000);
+                    Assert.assertEquals(learnInfo.getServerid(), 0);
+                
+                    // We are simulating an established leader, so the epoch is 1
+                    qp.setType(Leader.LEADERINFO);
+                    qp.setZxid(ZxidUtils.makeZxid(1, 0));
+                    byte protoBytes[] = new byte[4];
+                    ByteBuffer.wrap(protoBytes).putInt(0x10000);
+                    qp.setData(protoBytes);
+                    oa.writeRecord(qp, null);
+                
+                    readPacketSkippingPing(ia, qp);
+                    Assert.assertEquals(Leader.ACKEPOCH, qp.getType());
+                    Assert.assertEquals(0, qp.getZxid());
+                    Assert.assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());
+                    Assert.assertEquals(1, f.self.getAcceptedEpoch());
+                    Assert.assertEquals(0, f.self.getCurrentEpoch());
+                    
+                    // Send a diff
+                    qp.setType(Leader.DIFF);
+                    qp.setData(new byte[0]);
+                    qp.setZxid(zkDb.getDataTreeLastProcessedZxid());
+                    oa.writeRecord(qp, null);
+                    final long createSessionZxid = ZxidUtils.makeZxid(1, 2);
+                    proposeNewSession(qp, createSessionZxid, 0x333);
+                    oa.writeRecord(qp, null);
+                    qp.setType(Leader.COMMIT);
+                    qp.setZxid(createSessionZxid);
+                    oa.writeRecord(qp, null);
+                    qp.setType(Leader.NEWLEADER);
+                    qp.setZxid(ZxidUtils.makeZxid(1, 0));
+                    oa.writeRecord(qp, null);
+                    qp.setType(Leader.UPTODATE);
+                    qp.setZxid(0);
+                    oa.writeRecord(qp, null);
+                    
+                    // Read the uptodate ack
+                    readPacketSkippingPing(ia, qp);
+                    Assert.assertEquals(Leader.ACK, qp.getType());
+                    Assert.assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());
+                    
+                  
+                    // Get the ack of the new leader
+                    readPacketSkippingPing(ia, qp);
+                    Assert.assertEquals(Leader.ACK, qp.getType());
+                    Assert.assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());
+                    Assert.assertEquals(1, f.self.getAcceptedEpoch());
+                    Assert.assertEquals(1, f.self.getCurrentEpoch());
+                    
+                    Assert.assertEquals(createSessionZxid, f.fzk.getLastProcessedZxid());
+                    
+                    // Make sure the data was recorded in the filesystem ok
+                    ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));
+                    zkDb2.loadDataBase();
+                    LOG.info("zkdb2 sessions:" + zkDb2.getSessions());
+                    Assert.assertNotNull(zkDb2.getSessionWithTimeOuts().get(4L));
+                } finally {
+                    recursiveDelete(tmpDir);
+                }
+                
+            }
+
+            private void proposeNewSession(QuorumPacket qp, long zxid, long sessionId) throws IOException {
+                qp.setType(Leader.PROPOSAL);
+                qp.setZxid(zxid);
+                TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55, ZooDefs.OpCode.createSession);
+                CreateSessionTxn cst = new CreateSessionTxn(30000);
+                ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                OutputArchive boa = BinaryOutputArchive.getArchive(baos);
+                boa.writeRecord(hdr, null);
+                boa.writeRecord(cst, null);
+                qp.setData(baos.toByteArray());
+            }
+        });
+    }
+    
+    @Test
+    public void testNormalRun() throws Exception {
+        testLeaderConversation(new LeaderConversation() {
+            public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l)
+                    throws IOException {
+                Assert.assertEquals(0, l.self.getAcceptedEpoch());
+                Assert.assertEquals(0, l.self.getCurrentEpoch());
+                
+                /* we test a normal run. everything should work out well. */
+                LearnerInfo li = new LearnerInfo(1, 0x10000);
+                byte liBytes[] = new byte[12];
+                ByteBufferOutputStream.record2ByteBuffer(li,
+                        ByteBuffer.wrap(liBytes));
+                QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0,
+                        liBytes, null);
+                oa.writeRecord(qp, null);
+                
+                readPacketSkippingPing(ia, qp);
+                Assert.assertEquals(Leader.LEADERINFO, qp.getType());
+                Assert.assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());
+                Assert.assertEquals(ByteBuffer.wrap(qp.getData()).getInt(),
+                        0x10000);
+                Assert.assertEquals(1, l.self.getAcceptedEpoch());
+                Assert.assertEquals(0, l.self.getCurrentEpoch());
+                
+                qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);
+                oa.writeRecord(qp, null);
+                
+                readPacketSkippingPing(ia, qp);
+                Assert.assertEquals(Leader.DIFF, qp.getType());
+
+                readPacketSkippingPing(ia, qp);
+                Assert.assertEquals(Leader.NEWLEADER, qp.getType());
+                Assert.assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());
+                Assert.assertEquals(1, l.self.getAcceptedEpoch());
+                Assert.assertEquals(1, l.self.getCurrentEpoch());
+                
+                qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);
+                oa.writeRecord(qp, null);
+
+                readPacketSkippingPing(ia, qp);
+                Assert.assertEquals(Leader.UPTODATE, qp.getType());
+            }
+        });
+    }
+
+    @Test
+    public void testTxnTimeout() throws Exception {
+        testLeaderConversation(new LeaderConversation() {
+            public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l)
+                    throws IOException, InterruptedException, org.apache.zookeeper.server.quorum.Leader.XidRolloverException {
+                Assert.assertEquals(0, l.self.getAcceptedEpoch());
+                Assert.assertEquals(0, l.self.getCurrentEpoch());
+                
+                LearnerInfo li = new LearnerInfo(1, 0x10000);
+                byte liBytes[] = new byte[20];
+                ByteBufferOutputStream.record2ByteBuffer(li,
+                        ByteBuffer.wrap(liBytes));
+                QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0,
+                        liBytes, null);
+                oa.writeRecord(qp, null);
+                
+                readPacketSkippingPing(ia, qp);
+                Assert.assertEquals(Leader.LEADERINFO, qp.getType());
+                Assert.assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());
+                Assert.assertEquals(ByteBuffer.wrap(qp.getData()).getInt(),
+                        0x10000);
+                Assert.assertEquals(1, l.self.getAcceptedEpoch());
+                Assert.assertEquals(0, l.self.getCurrentEpoch());
+                
+                qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);
+                oa.writeRecord(qp, null);
+                
+                readPacketSkippingPing(ia, qp);
+                Assert.assertEquals(Leader.DIFF, qp.getType());
+
+                readPacketSkippingPing(ia, qp);
+                Assert.assertEquals(Leader.NEWLEADER, qp.getType());
+                Assert.assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());
+                Assert.assertEquals(1, l.self.getAcceptedEpoch());
+                Assert.assertEquals(1, l.self.getCurrentEpoch());
+                
+                qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);
+                oa.writeRecord(qp, null);
+
+                readPacketSkippingPing(ia, qp);
+                Assert.assertEquals(Leader.UPTODATE, qp.getType());
+
+                l.propose(createNodeRequest(l.zk.getZxid()));
+
+                readPacketSkippingPing(ia, qp);
+                Assert.assertEquals(Leader.PROPOSAL, qp.getType());
+
+                LOG.info("Proposal sent.");
+
+                for (int i = 0; i < (2 * SYNC_LIMIT) + 2; i++) {
+                    try {
+                        ia.readRecord(qp, null);
+                        LOG.info("Ping received: " + i);
+                        qp = new  QuorumPacket(Leader.PING, qp.getZxid(), "".getBytes(), null);
+                        oa.writeRecord(qp, null);
+                    } catch (EOFException e) {
+                        return;
+                    }
+                }
+
+                Assert.fail("Connection hasn't been closed by leader after transaction times out.");
+            }
+
+            private Request createNodeRequest(long zxid) throws IOException {
+                TxnHeader hdr = new TxnHeader(1, 1, zxid, 1, ZooDefs.OpCode.create);
+                CreateTxn ct = new CreateTxn("/foo", "data".getBytes(), null, true, 0);
+                ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                OutputArchive boa = BinaryOutputArchive.getArchive(baos);
+                boa.writeRecord(hdr, "header");
+                boa.writeRecord(ct, "txn");
+                baos.close();
+                Request rq = new Request(null, 1, 1, ZooDefs.OpCode.create, ByteBuffer.wrap(baos.toByteArray()), null);
+                rq.zxid = zxid;
+                rq.hdr = hdr;
+                rq.txn = ct;
+                return rq;
+            }
+        });
+    }
+
+    private void deserializeSnapshot(InputArchive ia)
+            throws IOException {
+        ZKDatabase zkdb = new ZKDatabase(null);
+        zkdb.deserializeSnapshot(ia);
+        String signature = ia.readString("signature");
+        assertEquals("BenWasHere", signature);
+    }
+
+    @Test
+    public void testNormalObserverRun() throws Exception {
+        testObserverConversation(new ObserverConversation() {
+            @Override
+            public void converseWithObserver(InputArchive ia, OutputArchive oa,
+                    Observer o) throws Exception {
+                File tmpDir = File.createTempFile("test", "dir");
+                tmpDir.delete();
+                tmpDir.mkdir();
+                File logDir = o.zk.getTxnLogFactory().getDataDir().getParentFile();
+                File snapDir = o.zk.getTxnLogFactory().getSnapDir().getParentFile();
+                try {
+                    Assert.assertEquals(0, o.self.getAcceptedEpoch());
+                    Assert.assertEquals(0, o.self.getCurrentEpoch());
+
+                    // Setup a database with a single /foo node
+                    ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));
+                    final long foo1Zxid = ZxidUtils.makeZxid(1, 1);
+                    final long foo2Zxid = ZxidUtils.makeZxid(1, 2);
+                    zkDb.processTxn(new TxnHeader(13, 1313, foo1Zxid, 33,
+                            ZooDefs.OpCode.create), new CreateTxn("/foo1",
+                            "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,
+                            false, 1));
+                    zkDb.processTxn(new TxnHeader(13, 1313, foo2Zxid, 33,
+                            ZooDefs.OpCode.create), new CreateTxn("/foo2",
+                            "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,
+                            false, 1));
+                    Stat stat = new Stat();
+                    Assert.assertEquals("data1",
+                            new String(zkDb.getData("/foo1", stat, null)));
+                    Assert.assertEquals("data1",
+                            new String(zkDb.getData("/foo2", stat, null)));
+
+                    QuorumPacket qp = new QuorumPacket();
+                    readPacketSkippingPing(ia, qp);
+                    Assert.assertEquals(Leader.OBSERVERINFO, qp.getType());
+                    Assert.assertEquals(qp.getZxid(), 0);
+                    LearnerInfo learnInfo = new LearnerInfo();
+                    ByteBufferInputStream.byteBuffer2Record(
+                            ByteBuffer.wrap(qp.getData()), learnInfo);
+                    Assert.assertEquals(learnInfo.getProtocolVersion(), 0x10000);
+                    Assert.assertEquals(learnInfo.getServerid(), 0);
+
+                    // We are simulating an established leader, so the epoch is 1
+                    qp.setType(Leader.LEADERINFO);
+                    qp.setZxid(ZxidUtils.makeZxid(1, 0));
+                    byte protoBytes[] = new byte[4];
+                    ByteBuffer.wrap(protoBytes).putInt(0x10000);
+                    qp.setData(protoBytes);
+                    oa.writeRecord(qp, null);
+
+                    readPacketSkippingPing(ia, qp);
+                    Assert.assertEquals(Leader.ACKEPOCH, qp.getType());
+                    Assert.assertEquals(0, qp.getZxid());
+                    Assert.assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer
+                            .wrap(qp.getData()).getInt());
+                    Assert.assertEquals(1, o.self.getAcceptedEpoch());
+                    Assert.assertEquals(0, o.self.getCurrentEpoch());
+
+                    // Send the snapshot we created earlier
+                    qp.setType(Leader.SNAP);
+                    qp.setData(new byte[0]);
+                    qp.setZxid(zkDb.getDataTreeLastProcessedZxid());
+                    oa.writeRecord(qp, null);
+                    zkDb.serializeSnapshot(oa);
+                    oa.writeString("BenWasHere", null);
+                    qp.setType(Leader.NEWLEADER);
+                    qp.setZxid(ZxidUtils.makeZxid(1, 0));
+                    oa.writeRecord(qp, null);
+
+                    // Get the ack of the new leader
+                    readPacketSkippingPing(ia, qp);
+                    Assert.assertEquals(Leader.ACK, qp.getType());
+                    Assert.assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());
+                    Assert.assertEquals(1, o.self.getAcceptedEpoch());
+                    Assert.assertEquals(1, o.self.getCurrentEpoch());
+
+                    Assert.assertEquals(foo2Zxid, o.zk.getLastProcessedZxid());
+
+                    // Make sure the data was recorded in the filesystem ok
+                    ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(
+                            logDir, snapDir));
+                    long lastZxid = zkDb2.loadDataBase();
+                    Assert.assertEquals("data1",
+                            new String(zkDb2.getData("/foo1", stat, null)));
+                    Assert.assertEquals(foo2Zxid, lastZxid);
+
+                    // Register watch
+                    TrackerWatcher watcher = new TrackerWatcher();
+                    Assert.assertEquals("data1", new String(o.zk
+                            .getZKDatabase().getData("/foo2", stat, watcher)));
+
+                    // Propose /foo1 update
+                    long proposalZxid = ZxidUtils.makeZxid(1, 1000);
+                    proposeSetData(qp, "/foo1", proposalZxid, "data2", 2);
+                    oa.writeRecord(qp, null);
+
+                    // Commit /foo1 update
+                    qp.setType(Leader.COMMIT);
+                    qp.setZxid(proposalZxid);
+                    oa.writeRecord(qp, null);
+
+                    // Inform /foo2 update
+                    long informZxid = ZxidUtils.makeZxid(1, 1001);
+                    proposeSetData(qp, "/foo2", informZxid, "data2", 2);
+                    qp.setType(Leader.INFORM);
+                    oa.writeRecord(qp, null);
+
+                    qp.setType(Leader.UPTODATE);
+                    qp.setZxid(0);
+                    oa.writeRecord(qp, null);
+
+                    // Read the uptodate ack
+                    readPacketSkippingPing(ia, qp);
+                    Assert.assertEquals(Leader.ACK, qp.getType());
+                    Assert.assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());
+
+                    // Data should get updated
+                    watcher.waitForChange();
+                    Assert.assertEquals("data2", new String(o.zk
+                            .getZKDatabase().getData("/foo1", stat, null)));
+                    Assert.assertEquals("data2", new String(o.zk
+                            .getZKDatabase().getData("/foo2", stat, null)));
+
+                    // Shutdown sequence guarantee that all pending requests
+                    // in sync request processor get flush to disk
+                    o.zk.shutdown();
+
+                    zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));
+                    lastZxid = zkDb2.loadDataBase();
+                    Assert.assertEquals("data2", new String(zkDb2.getData("/foo1", stat, null)));
+                    Assert.assertEquals("data2", new String(zkDb2.getData("/foo2", stat, null)));
+                    Assert.assertEquals(informZxid, lastZxid);
+                } finally {
+                    recursiveDelete(tmpDir);
+                }
+
+            }
+
+            private void proposeSetData(QuorumPacket qp, String path,
+                    long zxid, String data, int version) throws IOException {
+                qp.setType(Leader.PROPOSAL);
+                qp.setZxid(zxid);
+                TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55,
+                        ZooDefs.OpCode.setData);
+                SetDataTxn sdt = new SetDataTxn(path, data.getBytes(), version);
+                ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                OutputArchive boa = BinaryOutputArchive.getArchive(baos);
+                boa.writeRecord(hdr, null);
+                boa.writeRecord(sdt, null);
+                qp.setData(baos.toByteArray());
+            }
+        });
+    }
+
+    @Test
+    public void testLeaderBehind() throws Exception {
+        testLeaderConversation(new LeaderConversation() {
+            public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l)
+                    throws IOException {
+                /* we test a normal run. everything should work out well. */
+                LearnerInfo li = new LearnerInfo(1, 0x10000);
+                byte liBytes[] = new byte[12];
+                ByteBufferOutputStream.record2ByteBuffer(li,
+                        ByteBuffer.wrap(liBytes));
+                /* we are going to say we last acked epoch 20 */
+                QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, ZxidUtils.makeZxid(20, 0),
+                        liBytes, null);
+                oa.writeRecord(qp, null);
+                readPacketSkippingPing(ia, qp);
+                Assert.assertEquals(Leader.LEADERINFO, qp.getType());
+                Assert.assertEquals(ZxidUtils.makeZxid(21, 0), qp.getZxid());
+                Assert.assertEquals(ByteBuffer.wrap(qp.getData()).getInt(),
+                        0x10000);
+                qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);
+                oa.writeRecord(qp, null);
+                readPacketSkippingPing(ia, qp);
+                Assert.assertEquals(Leader.DIFF, qp.getType());
+                readPacketSkippingPing(ia, qp);
+                Assert.assertEquals(Leader.NEWLEADER, qp.getType());
+                Assert.assertEquals(ZxidUtils.makeZxid(21, 0), qp.getZxid());
+
+                qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);
+                oa.writeRecord(qp, null);
+
+                readPacketSkippingPing(ia, qp);
+                Assert.assertEquals(Leader.UPTODATE, qp.getType());
+            }
+        });
+    }
+
+    /**
+     * Tests that when a quorum of followers send LearnerInfo but do not ack the epoch (which is sent
+     * by the leader upon receipt of LearnerInfo from a quorum), the leader does not start using this epoch
+     * as it would in the normal case (when a quorum do ack the epoch). This tests ZK-1192
+     * @throws Exception
+     */
+    @Test
+    public void testAbandonBeforeACKEpoch() throws Exception {
+        testLeaderConversation(new LeaderConversation() {
+            public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l)
+                    throws IOException, InterruptedException {
+                /* we test a normal run. everything should work out well. */            	
+                LearnerInfo li = new LearnerInfo(1, 0x10000);
+                byte liBytes[] = new byte[12];
+                ByteBufferOutputStream.record2ByteBuffer(li,
+                        ByteBuffer.wrap(liBytes));
+                QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0,
+                        liBytes, null);
+                oa.writeRecord(qp, null);
+                readPacketSkippingPing(ia, qp);
+                Assert.assertEquals(Leader.LEADERINFO, qp.getType());
+                Assert.assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());
+                Assert.assertEquals(ByteBuffer.wrap(qp.getData()).getInt(),
+                        0x10000);                
+                Thread.sleep(l.self.getInitLimit()*l.self.getTickTime() + 5000);
+                
+                // The leader didn't get a quorum of acks - make sure that leader's current epoch is not advanced
+                Assert.assertEquals(0, l.self.getCurrentEpoch());			
+            }
+        });
+    }
+    
+    /**
+     * verify that a peer with dirty snapshot joining an established cluster
+     * does not go into an inconsistent state.
+     *
+     * {@link https://issues.apache.org/jira/browse/ZOOKEEPER-1558}
+     */
+    @Test
+    public void testDirtySnapshot()
+    throws IOException,
+        InterruptedException,
+        KeeperException,
+        NoSuchFieldException,
+        IllegalAccessException {
+        Socket pair[] = getSocketPair();
+        Socket leaderSocket = pair[0];
+        Socket followerSocket = pair[1];
+        File tmpDir = File.createTempFile("test", "dir");
+        tmpDir.delete();
+        tmpDir.mkdir();
+        LeadThread leadThread = null;
+        Leader leader = null;
+        try {
+            // Setup a database with two znodes
+            FileTxnSnapLog snapLog = new FileTxnSnapLog(tmpDir, tmpDir);
+            ZKDatabase zkDb = new ZKDatabase(snapLog);
+
+            long zxid = ZxidUtils.makeZxid(0, 1);
+            String path = "/foo";
+            zkDb.processTxn(new TxnHeader(13,1000,zxid,30,ZooDefs.OpCode.create),
+                                            new CreateTxn(path, "fpjwasalsohere".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));
+            Stat stat = new Stat();
+            Assert.assertEquals("fpjwasalsohere", new String(zkDb.getData(path, stat, null)));
+
+            // Close files
+            snapLog.close();
+
+            QuorumPeer peer = createQuorumPeer(tmpDir);
+
+            leader = createLeader(tmpDir, peer);
+            peer.leader = leader;
+
+            // Set the last accepted epoch and current epochs to be 1
+            peer.setAcceptedEpoch(0);
+            peer.setCurrentEpoch(0);
+
+            leadThread = new LeadThread(leader);
+            leadThread.start();
+
+            while(leader.cnxAcceptor == null || !leader.cnxAcceptor.isAlive()) {
+                Thread.sleep(20);
+            }
+
+            leader.shutdown("Shutting down the leader");
+
+            // Check if there is a valid snapshot (we better not have it)
+            File snapDir = new File (tmpDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);
+            List<File> files = Util.sortDataDir(snapDir.listFiles(),"snapshot", false);
+
+            for (File f : files) {
+                try {
+                    Assert.assertFalse("Found a valid snapshot", Util.isValidSnapshot(f));
+                } catch (IOException e) {
+                    LOG.info("invalid snapshot " + f, e);
+                }
+            }
+
+        } finally {
+            if (leader != null) {
+                leader.shutdown("end of test");
+            }
+            if (leadThread != null) {
+                leadThread.interrupt();
+                leadThread.join();
+            }
+            recursiveDelete(tmpDir);
+        }
+    }
+
+    private void recursiveDelete(File file) {
+        if (file.isFile()) {
+            file.delete();
+        } else {
+            // might return null if deleted out from under us...
+            File[] files = file.listFiles();
+            if (files != null) {
+                for(File c: files) {
+                    recursiveDelete(c);
+                }
+            }
+            file.delete();
+        }
+    }
+
+    private Leader createLeader(File tmpDir, QuorumPeer peer)
+    throws IOException, NoSuchFieldException, IllegalAccessException{
+        LeaderZooKeeperServer zk = prepareLeader(tmpDir, peer);
+        return new Leader(peer, zk);
+    }
+            
+    private Leader createMockLeader(File tmpDir, QuorumPeer peer)
+    throws IOException, NoSuchFieldException, IllegalAccessException{
+        LeaderZooKeeperServer zk = prepareLeader(tmpDir, peer);
+        return new MockLeader(peer, zk);
+    }
+            
+    private LeaderZooKeeperServer prepareLeader(File tmpDir, QuorumPeer peer)
+    throws IOException, NoSuchFieldException, IllegalAccessException {
+        FileTxnSnapLog logFactory = new FileTxnSnapLog(tmpDir, tmpDir);
+        peer.setTxnFactory(logFactory);
+        Field addrField = peer.getClass().getDeclaredField("myQuorumAddr");
+        addrField.setAccessible(true);
+        addrField.set(peer, new InetSocketAddress(PortAssignment.unique()));
+        ZKDatabase zkDb = new ZKDatabase(logFactory);
+        LeaderZooKeeperServer zk = new LeaderZooKeeperServer(logFactory, peer, new ZooKeeperServer.BasicDataTreeBuilder(), zkDb);
+        return zk;
+    }
+
+    static class ConversableFollower extends Follower {
+
+        ConversableFollower(QuorumPeer self, FollowerZooKeeperServer zk) {
+            super(self, zk);
+        }
+
+        InetSocketAddress leaderAddr;
+        public void setLeaderSocketAddress(InetSocketAddress addr) {
+            leaderAddr = addr;
+        }
+        
+        @Override
+        protected InetSocketAddress findLeader() {
+            return leaderAddr;
+        }
+    }
+    private ConversableFollower createFollower(File tmpDir, QuorumPeer peer)
+    throws IOException {
+        FileTxnSnapLog logFactory = new FileTxnSnapLog(tmpDir, tmpDir);
+        peer.setTxnFactory(logFactory);
+        ZKDatabase zkDb = new ZKDatabase(logFactory);
+        FollowerZooKeeperServer zk = new FollowerZooKeeperServer(logFactory, peer, new ZooKeeperServer.BasicDataTreeBuilder(), zkDb);
+        peer.setZKDatabase(zkDb);
+        return new ConversableFollower(peer, zk);
+    }
+
+    static class ConversableObserver extends Observer {
+        
+        ConversableObserver(QuorumPeer self, ObserverZooKeeperServer zk) {
+            super(self, zk);
+        }
+        
+        InetSocketAddress leaderAddr;
+        public void setLeaderSocketAddress(InetSocketAddress addr) {
+            leaderAddr = addr;
+        }
+        
+        @Override
+        protected InetSocketAddress findLeader() {
+            return leaderAddr;
+        }
+    }
+        
+    private ConversableObserver createObserver(File tmpDir, QuorumPeer peer)
+            throws IOException {
+        FileTxnSnapLog logFactory = new FileTxnSnapLog(tmpDir, tmpDir);
+        peer.setTxnFactory(logFactory);
+        DataTreeBuilder treeBuilder = new ZooKeeperServer.BasicDataTreeBuilder();
+        ZKDatabase zkDb = new ZKDatabase(logFactory);
+        ObserverZooKeeperServer zk = new ObserverZooKeeperServer(logFactory, peer, treeBuilder, zkDb);
+        peer.setZKDatabase(zkDb);
+        return new ConversableObserver(peer, zk);
+    }
+        
+    
+    private QuorumPeer createQuorumPeer(File tmpDir) throws IOException,
+            FileNotFoundException {
+        QuorumPeer peer = new QuorumPeer();
+        peer.syncLimit = SYNC_LIMIT;
+        peer.initLimit = 2;
+        peer.tickTime = 2000;
+        peer.quorumPeers = new HashMap<Long, QuorumServer>();
+        peer.quorumPeers.put(1L, new QuorumServer(0, new InetSocketAddress(33221)));
+        peer.quorumPeers.put(1L, new QuorumServer(1, new InetSocketAddress(33223)));
+        peer.setQuorumVerifier(new QuorumMaj(3));
+        peer.setCnxnFactory(new NullServerCnxnFactory());
+        File version2 = new File(tmpDir, "version-2");
+        version2.mkdir();
+        FileOutputStream fos;
+        fos = new FileOutputStream(new File(version2, "currentEpoch"));
+        fos.write("0\n".getBytes());
+        fos.close();
+        fos = new FileOutputStream(new File(version2, "acceptedEpoch"));
+        fos.write("0\n".getBytes());
+        fos.close();
+        return peer;
+    }
+
+    private String readContentsOfFile(File f) throws IOException {
+        return new BufferedReader(new FileReader(f)).readLine();
+    }
+
+    @Test
+    public void testInitialAcceptedCurrent() throws Exception {
+        File tmpDir = File.createTempFile("test", ".dir");
+        tmpDir.delete();
+        tmpDir.mkdir();
+        try {
+            FileTxnSnapLog logFactory = new FileTxnSnapLog(tmpDir, tmpDir);
+            File version2 = new File(tmpDir, "version-2");
+            version2.mkdir();
+            long zxid = ZxidUtils.makeZxid(3, 3);
+
+            TxnHeader hdr = new TxnHeader(1, 1, zxid, 1, ZooDefs.OpCode.error);
+            ErrorTxn txn = new ErrorTxn(1);
+            byte[] buf = Util.marshallTxnEntry(hdr, txn);
+            Request req = new Request(null, 1, 1, ZooDefs.OpCode.error,
+                    ByteBuffer.wrap(buf), null);
+            req.hdr = hdr;
+            req.txn = txn;
+            logFactory.append(req);
+            logFactory.commit();
+            ZKDatabase zkDb = new ZKDatabase(logFactory);
+            QuorumPeer peer = new QuorumPeer();
+            peer.setZKDatabase(zkDb);
+            peer.setTxnFactory(logFactory);
+            peer.getLastLoggedZxid();
+            Assert.assertEquals(3, peer.getAcceptedEpoch());
+            Assert.assertEquals(3, peer.getCurrentEpoch());
+            Assert.assertEquals(3, Integer
+                    .parseInt(readContentsOfFile(new File(version2,
+                            QuorumPeer.CURRENT_EPOCH_FILENAME))));
+            Assert.assertEquals(3, Integer
+                    .parseInt(readContentsOfFile(new File(version2,
+                            QuorumPeer.ACCEPTED_EPOCH_FILENAME))));
+        } finally {
+            recursiveDelete(tmpDir);
+        }
+    }
+}
diff -uNr zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/FLENewEpochTest.java zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/FLENewEpochTest.java
--- zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/FLENewEpochTest.java	2014-02-20 14:14:10.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/FLENewEpochTest.java	2016-12-26 10:45:28.000000000 +0400
@@ -157,9 +157,8 @@
           LOG.info("TestLE: " + getTestName()+ ", " + count);
           for(int i = 0; i < count; i++) {
               peers.put(Long.valueOf(i),
-                      new QuorumServer(i,
-                              new InetSocketAddress(PortAssignment.unique()),
-                      new InetSocketAddress(PortAssignment.unique())));
+                        new QuorumServer(i, "0.0.0.0", PortAssignment.unique(),
+                                         PortAssignment.unique(), null));
               tmpdir[i] = ClientBase.createTmpDir();
               port[i] = PortAssignment.unique();
           }
diff -uNr zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/FLEPredicateTest.java zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/FLEPredicateTest.java
--- zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/FLEPredicateTest.java	2014-02-20 14:14:10.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/FLEPredicateTest.java	2016-12-26 10:49:12.000000000 +0400
@@ -62,9 +62,8 @@
          */
         for(int i = 0; i < 3; i++) {
             peers.put(Long.valueOf(i),
-                    new QuorumServer(i,
-                            new InetSocketAddress(PortAssignment.unique()),
-                    new InetSocketAddress(PortAssignment.unique())));
+                       new QuorumServer(i, "0.0.0.0", PortAssignment.unique(),
+                                        PortAssignment.unique(), null));
         }
 
         /*
diff -uNr zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/FLEPredicateTest.java.orig zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/FLEPredicateTest.java.orig
--- zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/FLEPredicateTest.java.orig	1970-01-01 04:00:00.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/FLEPredicateTest.java.orig	2014-02-20 14:14:10.000000000 +0400
@@ -0,0 +1,105 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.test;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.util.HashMap;
+
+import org.apache.zookeeper.server.quorum.FastLeaderElection;
+import org.apache.zookeeper.server.quorum.QuorumCnxManager;
+import org.apache.zookeeper.server.quorum.QuorumPeer;
+import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;
+import org.apache.zookeeper.PortAssignment;
+import org.apache.zookeeper.ZKTestCase;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+public class FLEPredicateTest extends ZKTestCase {
+    
+    protected static final Logger LOG = LoggerFactory.getLogger(FLEPredicateTest.class);
+    
+    class MockFLE extends FastLeaderElection {
+        MockFLE(QuorumPeer peer){
+            super(peer, new QuorumCnxManager(peer));
+        }
+        
+        boolean predicate(long newId, long newZxid, long newEpoch, long curId, long curZxid, long curEpoch){
+            return this.totalOrderPredicate(newId, newZxid, newEpoch, curId, curZxid, curEpoch);
+        }
+    }
+    
+    
+    HashMap<Long,QuorumServer> peers;
+    
+    @Test
+    public void testPredicate() throws IOException {
+        
+        peers = new HashMap<Long,QuorumServer>(3);
+        
+        /*
+         * Creates list of peers.
+         */
+        for(int i = 0; i < 3; i++) {
+            peers.put(Long.valueOf(i),
+                    new QuorumServer(i,
+                            new InetSocketAddress(PortAssignment.unique()),
+                    new InetSocketAddress(PortAssignment.unique())));
+        }
+
+        /*
+         * Creating peer.
+         */
+        try{
+            File tmpDir = ClientBase.createTmpDir();
+            QuorumPeer peer = new QuorumPeer(peers, tmpDir, tmpDir,
+                                        PortAssignment.unique(), 3, 0, 1000, 2, 2);
+        
+            MockFLE mock = new MockFLE(peer);
+            
+            /*
+             * Lower epoch must return false
+             */
+            
+            Assert.assertFalse (mock.predicate(4L, 0L, 0L, 3L, 0L, 2L));
+            
+            /*
+             * Later epoch
+             */
+            Assert.assertTrue (mock.predicate(0L, 0L, 1L, 1L, 0L, 0L));
+        
+            /*
+             * Higher zxid
+             */
+            Assert.assertTrue(mock.predicate(0L, 1L, 0L, 1L, 0L, 0L));
+        
+            /*
+             * Higher id
+             */
+            Assert.assertTrue(mock.predicate(1L, 1L, 0L, 0L, 1L, 0L));
+        } catch (IOException e) {
+            LOG.error("Exception while creating quorum peer", e);
+            Assert.fail("Exception while creating quorum peer");
+        }
+    }
+}
diff -uNr zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/FLEPredicateTest.java.rej zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/FLEPredicateTest.java.rej
--- zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/FLEPredicateTest.java.rej	1970-01-01 04:00:00.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/FLEPredicateTest.java.rej	2016-12-26 10:45:28.000000000 +0400
@@ -0,0 +1,20 @@
+***************
+*** 62,70 ****
+           */
+          for(int i = 0; i < 3; i++) {
+              peers.put(Long.valueOf(i),
+-                     new QuorumServer(i,
+-                             new InetSocketAddress(PortAssignment.unique()),
+-                     new InetSocketAddress(PortAssignment.unique())));
+          }
+  
+          /*
+--- 62,69 ----
+           */
+          for(int i = 0; i < 3; i++) {
+              peers.put(Long.valueOf(i),
++                       new QuorumServer(i, "0.0.0.0", PortAssignment.unique(),
++                                        PortAssignment.unique(), null));
+          }
+  
+          /*
diff -uNr zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/FLERestartTest.java zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/FLERestartTest.java
--- zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/FLERestartTest.java	2014-02-20 14:14:10.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/FLERestartTest.java	2016-12-26 10:45:28.000000000 +0400
@@ -178,9 +178,8 @@
         LOG.info("TestLE: " + getTestName()+ ", " + count);
         for(int i = 0; i < count; i++) {
             peers.put(Long.valueOf(i),
-                    new QuorumServer(i,
-                            new InetSocketAddress(PortAssignment.unique()),
-                    new InetSocketAddress(PortAssignment.unique())));
+                      new QuorumServer(i, "0.0.0.0", PortAssignment.unique(),
+                                       PortAssignment.unique(), null));
             tmpdir[i] = ClientBase.createTmpDir();
             port[i] = PortAssignment.unique();
         }
diff -uNr zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/FLETest.java zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/FLETest.java
--- zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/FLETest.java	2014-02-20 14:14:10.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/FLETest.java	2016-12-26 10:45:28.000000000 +0400
@@ -269,9 +269,8 @@
         LOG.info("TestLE: " + getTestName()+ ", " + count);
         for(int i = 0; i < count; i++) {
             peers.put(Long.valueOf(i),
-                    new QuorumServer(i,
-                            new InetSocketAddress(PortAssignment.unique()),
-                    new InetSocketAddress(PortAssignment.unique())));
+                      new QuorumServer(i, "0.0.0.0", PortAssignment.unique(),
+                                       PortAssignment.unique(), null));
             tmpdir[i] = ClientBase.createTmpDir();
             port[i] = PortAssignment.unique();
         }
@@ -366,9 +365,8 @@
         ArrayList<QuorumPeer> peerList = new ArrayList<QuorumPeer>();
         for(sid = 0; sid < 3; sid++) {
             peers.put(Long.valueOf(sid),
-                    new QuorumServer(sid,
-                            new InetSocketAddress(PortAssignment.unique()),
-                    new InetSocketAddress(PortAssignment.unique())));
+                      new QuorumServer(sid, "0.0.0.0", PortAssignment.unique(),
+                                       PortAssignment.unique(), null));
             tmpdir[sid] = ClientBase.createTmpDir();
             port[sid] = PortAssignment.unique();
         }
@@ -423,9 +421,8 @@
         ArrayList<QuorumPeer> peerList = new ArrayList<QuorumPeer>();
         for(sid = 0; sid < 3; sid++) {
             peers.put(Long.valueOf(sid),
-                    new QuorumServer(sid,
-                            new InetSocketAddress(PortAssignment.unique()),
-                    new InetSocketAddress(PortAssignment.unique())));
+                      new QuorumServer(sid, "0.0.0.0", PortAssignment.unique(),
+                                       PortAssignment.unique(), null));
             tmpdir[sid] = ClientBase.createTmpDir();
             port[sid] = PortAssignment.unique();
         }
diff -uNr zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/FLEZeroWeightTest.java zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/FLEZeroWeightTest.java
--- zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/FLEZeroWeightTest.java	2014-02-20 14:14:10.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/FLEZeroWeightTest.java	2016-12-26 10:45:28.000000000 +0400
@@ -153,9 +153,7 @@
         LOG.info("TestZeroWeightQuorum: " + getTestName()+ ", " + count);
         for(int i = 0; i < count; i++) {
             peers.put(Long.valueOf(i),
-                    new QuorumServer(i,
-                            new InetSocketAddress(PortAssignment.unique()),
-                    new InetSocketAddress(PortAssignment.unique())));
+                      new QuorumServer(i, "0.0.0.0", PortAssignment.unique(), PortAssignment.unique(), null));
             tmpdir[i] = ClientBase.createTmpDir();
             port[i] = PortAssignment.unique();
         }
diff -uNr zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/HierarchicalQuorumTest.java zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/HierarchicalQuorumTest.java
--- zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/HierarchicalQuorumTest.java	2014-02-20 14:14:10.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/HierarchicalQuorumTest.java	2016-12-26 10:45:28.000000000 +0400
@@ -128,23 +128,13 @@
         int initLimit = 3;
         int syncLimit = 3;
         HashMap<Long,QuorumServer> peers = new HashMap<Long,QuorumServer>();
-        peers.put(Long.valueOf(1), new QuorumServer(1, 
-                new InetSocketAddress("127.0.0.1", port1 + 1000),
-                new InetSocketAddress("127.0.0.1", leport1 + 1000)));        
-        peers.put(Long.valueOf(2), new QuorumServer(2, 
-                new InetSocketAddress("127.0.0.1", port2 + 1000),
-                new InetSocketAddress("127.0.0.1", leport2 + 1000)));
-        peers.put(Long.valueOf(3), new QuorumServer(3, 
-                new InetSocketAddress("127.0.0.1", port3 + 1000),
-                new InetSocketAddress("127.0.0.1", leport3 + 1000)));
-        peers.put(Long.valueOf(4), new QuorumServer(4,
-                new InetSocketAddress("127.0.0.1", port4 + 1000),
-                new InetSocketAddress("127.0.0.1", leport4 + 1000),
+        peers.put(Long.valueOf(1), new QuorumServer(1, "127.0.0.1", port1 + 1000, leport1 + 1000, null));
+        peers.put(Long.valueOf(2), new QuorumServer(2, "127.0.0.1", port2 + 1000, leport2 + 1000, null));
+        peers.put(Long.valueOf(3), new QuorumServer(3, "127.0.0.1", port3 + 1000, leport3 + 1000, null));
+        peers.put(Long.valueOf(4), new QuorumServer(4, "127.0.0.1", port4 + 1000, leport4 + 1000,
                 withObservers ? QuorumPeer.LearnerType.OBSERVER
                         : QuorumPeer.LearnerType.PARTICIPANT));
-        peers.put(Long.valueOf(5), new QuorumServer(5,
-                new InetSocketAddress("127.0.0.1", port5 + 1000),
-                new InetSocketAddress("127.0.0.1", leport5 + 1000),
+        peers.put(Long.valueOf(5), new QuorumServer(5, "127.0.0.1", port5 + 1000, leport5 + 1000,
                 withObservers ? QuorumPeer.LearnerType.OBSERVER
                         : QuorumPeer.LearnerType.PARTICIPANT));
 
diff -uNr zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/LENonTerminateTest.java zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/LENonTerminateTest.java
--- zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/LENonTerminateTest.java	2014-02-20 14:14:10.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/LENonTerminateTest.java	2016-12-26 10:45:28.000000000 +0400
@@ -300,9 +300,8 @@
         for(int i = 0; i < count; i++) {
             int clientport = PortAssignment.unique();
             peers.put(Long.valueOf(i),
-                    new QuorumServer(i,
-                            new InetSocketAddress("127.0.0.1", clientport),
-                            new InetSocketAddress("127.0.0.1", PortAssignment.unique())));
+                      new QuorumServer(i, "127.0.0.1", clientport,
+                                       PortAssignment.unique(), null));
             tmpdir[i] = ClientBase.createTmpDir();
             port[i] = clientport;
         }
diff -uNr zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/LETest.java zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/LETest.java
--- zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/LETest.java	2014-02-20 14:14:10.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/LETest.java	2016-12-26 10:45:28.000000000 +0400
@@ -98,9 +98,7 @@
         votes = new Vote[count];
         for(int i = 0; i < count; i++) {
             peers.put(Long.valueOf(i),
-                    new QuorumServer(i,
-                            new InetSocketAddress("127.0.0.1",
-                                    PortAssignment.unique())));
+                      new QuorumServer(i, "127.0.0.1", PortAssignment.unique(), 0, null));
             tmpdir[i] = ClientBase.createTmpDir();
             port[i] = PortAssignment.unique();
         }
diff -uNr zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/QuorumBase.java zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/QuorumBase.java
--- zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/QuorumBase.java	2014-02-20 14:14:10.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/QuorumBase.java	2016-12-26 10:45:28.000000000 +0400
@@ -118,25 +118,20 @@
         int initLimit = 3;
         int syncLimit = 3;
         HashMap<Long,QuorumServer> peers = new HashMap<Long,QuorumServer>();
-        peers.put(Long.valueOf(1), new QuorumServer(1, 
-                new InetSocketAddress("127.0.0.1", port1 + 1000),
-                new InetSocketAddress("127.0.0.1", portLE1 + 1000),
-                LearnerType.PARTICIPANT));
-        peers.put(Long.valueOf(2), new QuorumServer(2, 
-                new InetSocketAddress("127.0.0.1", port2 + 1000),
-                new InetSocketAddress("127.0.0.1", portLE2 + 1000),
-                LearnerType.PARTICIPANT));
-        peers.put(Long.valueOf(3), new QuorumServer(3, 
-                new InetSocketAddress("127.0.0.1", port3 + 1000),
-                new InetSocketAddress("127.0.0.1", portLE3 + 1000),
-                LearnerType.PARTICIPANT));
-        peers.put(Long.valueOf(4), new QuorumServer(4, 
-                new InetSocketAddress("127.0.0.1", port4 + 1000),
-                new InetSocketAddress("127.0.0.1", portLE4 + 1000),
-                LearnerType.PARTICIPANT));
-        peers.put(Long.valueOf(5), new QuorumServer(5, 
-                new InetSocketAddress("127.0.0.1", port5 + 1000),
-                new InetSocketAddress("127.0.0.1", portLE5 + 1000),
+        peers.put(Long.valueOf(1), new QuorumServer(1, "127.0.0.1", port1 + 1000,
+                                                    portLE1 + 1000,
+                LearnerType.PARTICIPANT));
+        peers.put(Long.valueOf(2), new QuorumServer(2, "127.0.0.1", port2 + 1000,
+                                                    portLE2 + 1000,
+                LearnerType.PARTICIPANT));
+        peers.put(Long.valueOf(3), new QuorumServer(3, "127.0.0.1", port3 + 1000,
+                                                    portLE3 + 1000,
+                LearnerType.PARTICIPANT));
+        peers.put(Long.valueOf(4), new QuorumServer(4, "127.0.0.1", port4 + 1000,
+                                                    portLE4 + 1000,
+                LearnerType.PARTICIPANT));
+        peers.put(Long.valueOf(5), new QuorumServer(5, "127.0.0.1", port5 + 1000,
+                                                    portLE5 + 1000,
                 LearnerType.PARTICIPANT));
         
         if (withObservers) {
@@ -232,25 +227,20 @@
         if(peers == null){
             peers = new HashMap<Long,QuorumServer>();
 
-            peers.put(Long.valueOf(1), new QuorumServer(1, 
-                new InetSocketAddress("127.0.0.1", port1 + 1000),
-                new InetSocketAddress("127.0.0.1", portLE1 + 1000),
-                LearnerType.PARTICIPANT));
-            peers.put(Long.valueOf(2), new QuorumServer(2, 
-                new InetSocketAddress("127.0.0.1", port2 + 1000),
-                new InetSocketAddress("127.0.0.1", portLE2 + 1000),
-                LearnerType.PARTICIPANT));
-            peers.put(Long.valueOf(3), new QuorumServer(3, 
-                new InetSocketAddress("127.0.0.1", port3 + 1000),
-                new InetSocketAddress("127.0.0.1", portLE3 + 1000),
-                LearnerType.PARTICIPANT));
-            peers.put(Long.valueOf(4), new QuorumServer(4, 
-                new InetSocketAddress("127.0.0.1", port4 + 1000),
-                new InetSocketAddress("127.0.0.1", portLE4 + 1000),
-                LearnerType.PARTICIPANT));
-            peers.put(Long.valueOf(5), new QuorumServer(5, 
-                new InetSocketAddress("127.0.0.1", port5 + 1000),
-                new InetSocketAddress("127.0.0.1", portLE5 + 1000),
+            peers.put(Long.valueOf(1), new QuorumServer(1, "127.0.0.1", port1 + 1000,
+                                                        portLE1 + 1000,
+                LearnerType.PARTICIPANT));
+            peers.put(Long.valueOf(2), new QuorumServer(2, "127.0.0.1", port2 + 1000,
+                                                        portLE2 + 1000,
+                LearnerType.PARTICIPANT));
+            peers.put(Long.valueOf(3), new QuorumServer(3, "127.0.0.1", port3 + 1000,
+                                                        portLE3 + 1000,
+                LearnerType.PARTICIPANT));
+            peers.put(Long.valueOf(4), new QuorumServer(4, "127.0.0.1", port4 + 1000,
+                                                        portLE4 + 1000,
+                LearnerType.PARTICIPANT));
+            peers.put(Long.valueOf(5), new QuorumServer(5, "127.0.0.1", port5 + 1000,
+                                                        portLE5 + 1000,
                 LearnerType.PARTICIPANT));
         }
         
diff -uNr zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/QuorumUtil.java zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/QuorumUtil.java
--- zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/QuorumUtil.java	2014-02-20 14:14:10.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/QuorumUtil.java	2016-12-26 10:45:28.000000000 +0400
@@ -99,9 +99,10 @@
                 ps.clientPort = PortAssignment.unique();
                 peers.put(i, ps);
 
-                peersView.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(
-                        "127.0.0.1", ps.clientPort + 1000), new InetSocketAddress("127.0.0.1",
-                        PortAssignment.unique() + 1000), LearnerType.PARTICIPANT));
+                peersView.put(Long.valueOf(i),
+                              new QuorumServer(i, "127.0.0.1", ps.clientPort + 1000,
+                                               PortAssignment.unique() + 1000,
+                                               LearnerType.PARTICIPANT));
                 hostPort += "127.0.0.1:" + ps.clientPort + ((i == ALL) ? "" : ",");
             }
             for (int i = 1; i <= ALL; ++i) {
diff -uNr zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/TruncateTest.java zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/TruncateTest.java
--- zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/TruncateTest.java	2014-02-20 14:14:10.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/TruncateTest.java	2016-12-26 10:45:28.000000000 +0400
@@ -171,9 +171,9 @@
         
         // Start up two of the quorum and add 10 txns
         HashMap<Long,QuorumServer> peers = new HashMap<Long,QuorumServer>();
-        peers.put(Long.valueOf(1), new QuorumServer(1, new InetSocketAddress("127.0.0.1", port1 + 1000)));
-        peers.put(Long.valueOf(2), new QuorumServer(2, new InetSocketAddress("127.0.0.1", port2 + 1000)));
-        peers.put(Long.valueOf(3), new QuorumServer(3, new InetSocketAddress("127.0.0.1", port3 + 1000)));
+        peers.put(Long.valueOf(1), new QuorumServer(1, "127.0.0.1", port1 + 1000, 0, null));
+        peers.put(Long.valueOf(2), new QuorumServer(2, "127.0.0.1", port2 + 1000, 0, null));
+        peers.put(Long.valueOf(3), new QuorumServer(3, "127.0.0.1", port3 + 1000, 0, null));
 
         QuorumPeer s2 = new QuorumPeer(peers, dataDir2, dataDir2, port2, 0, 2, tickTime, initLimit, syncLimit);
         s2.start();
diff -uNr zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/TruncateTest.java.orig zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/TruncateTest.java.orig
--- zookeeper-3.4.6/src/java/test/org/apache/zookeeper/test/TruncateTest.java.orig	1970-01-01 04:00:00.000000000 +0400
+++ zookeeper-3.4.6-b/src/java/test/org/apache/zookeeper/test/TruncateTest.java.orig	2014-02-20 14:14:10.000000000 +0400
@@ -0,0 +1,226 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.test;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.util.HashMap;
+
+import junit.framework.Assert;
+
+import org.apache.jute.Record;
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.KeeperException;
+import org.apache.zookeeper.PortAssignment;
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.ZKTestCase;
+import org.apache.zookeeper.ZooDefs;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.data.Stat;
+import org.apache.zookeeper.server.Request;
+import org.apache.zookeeper.server.ServerCnxnFactory;
+import org.apache.zookeeper.server.ZKDatabase;
+import org.apache.zookeeper.server.ZooKeeperServer;
+import org.apache.zookeeper.server.persistence.FileTxnLog;
+import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
+import org.apache.zookeeper.server.persistence.TxnLog.TxnIterator;
+import org.apache.zookeeper.server.quorum.QuorumPeer;
+import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;
+import org.apache.zookeeper.txn.SetDataTxn;
+import org.apache.zookeeper.txn.TxnHeader;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class TruncateTest extends ZKTestCase {
+	private static final Logger LOG = LoggerFactory.getLogger(TruncateTest.class);
+    File dataDir1, dataDir2, dataDir3;
+    final int baseHostPort = PortAssignment.unique();
+    
+    @Before
+    public void setUp() throws IOException {
+        dataDir1 = ClientBase.createTmpDir();
+        dataDir2 = ClientBase.createTmpDir();
+        dataDir3 = ClientBase.createTmpDir();
+    }
+    
+    @After
+    public void tearDown() {
+        ClientBase.recursiveDelete(dataDir1);
+        ClientBase.recursiveDelete(dataDir2);
+        ClientBase.recursiveDelete(dataDir3);
+    }
+    
+    volatile boolean connected;
+    Watcher nullWatcher = new Watcher() {
+        @Override
+        public void process(WatchedEvent event) {
+            connected = event.getState() == Watcher.Event.KeeperState.SyncConnected;
+        }
+    };
+
+    @Test
+    public void testTruncationStreamReset() throws Exception {
+        File tmpdir = ClientBase.createTmpDir();
+        FileTxnSnapLog snaplog = new FileTxnSnapLog(tmpdir, tmpdir);
+        ZKDatabase zkdb = new ZKDatabase(snaplog);
+
+        for (int i = 1; i <= 100; i++) {
+            append(zkdb, i);
+        }
+
+        zkdb.truncateLog(1);
+
+        append(zkdb, 200);
+
+        zkdb.close();
+
+        // verify that the truncation and subsequent append were processed
+        // correctly
+        FileTxnLog txnlog = new FileTxnLog(new File(tmpdir, "version-2"));
+        TxnIterator iter = txnlog.read(1);
+
+        TxnHeader hdr = iter.getHeader();
+        Record txn = iter.getTxn();
+        Assert.assertEquals(1, hdr.getZxid());
+        Assert.assertTrue(txn instanceof SetDataTxn);
+
+        iter.next();
+
+        hdr = iter.getHeader();
+        txn = iter.getTxn();
+        Assert.assertEquals(200, hdr.getZxid());
+        Assert.assertTrue(txn instanceof SetDataTxn);
+        iter.close();
+        ClientBase.recursiveDelete(tmpdir);
+    }
+
+    private void append(ZKDatabase zkdb, int i) throws IOException {
+        TxnHeader hdr = new TxnHeader(1, 1, i, 1, ZooDefs.OpCode.setData);
+        Record txn = new SetDataTxn("/foo" + i, new byte[0], 1);
+        Request req = new Request(null, 0, 0, 0, null, null);
+        req.hdr = hdr;
+        req.txn = txn;
+
+        zkdb.append(req);
+        zkdb.commit();
+    }
+
+    @Test
+    public void testTruncate() throws IOException, InterruptedException, KeeperException {
+        // Prime the server that is going to come in late with 50 txns
+        String hostPort = "127.0.0.1:" + baseHostPort;
+        int maxCnxns = 100;
+        ServerCnxnFactory factory = ClientBase.createNewServerInstance(null,
+                hostPort, maxCnxns);
+        ClientBase.startServerInstance(dataDir1, factory, hostPort);
+        ClientBase.shutdownServerInstance(factory, hostPort);
+
+        // standalone starts with 0 epoch while quorum starts with 1
+        File origfile = new File(new File(dataDir1, "version-2"), "snapshot.0");
+        File newfile = new File(new File(dataDir1, "version-2"), "snapshot.100000000");
+        origfile.renameTo(newfile);
+
+        factory = ClientBase.createNewServerInstance(null, hostPort, maxCnxns);
+        ClientBase.startServerInstance(dataDir1, factory, hostPort);
+
+        ZooKeeper zk = new ZooKeeper(hostPort, 15000, nullWatcher);
+        for(int i = 0; i < 50; i++) {
+            zk.create("/" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+        }
+        zk.close();
+        
+        ZKDatabase zkDb;
+        {
+            ZooKeeperServer zs = ClientBase.getServer(factory);
+    
+            zkDb = zs.getZKDatabase();
+        }
+        factory.shutdown();
+        try {
+            zkDb.close();
+        } catch (IOException ie) {
+            LOG.warn("Error closing logs ", ie);
+        }
+        int tickTime = 2000;
+        int initLimit = 3;
+        int syncLimit = 3;
+        int port1 = baseHostPort+1;
+        int port2 = baseHostPort+2;
+        int port3 = baseHostPort+3;
+        
+        // Start up two of the quorum and add 10 txns
+        HashMap<Long,QuorumServer> peers = new HashMap<Long,QuorumServer>();
+        peers.put(Long.valueOf(1), new QuorumServer(1, new InetSocketAddress("127.0.0.1", port1 + 1000)));
+        peers.put(Long.valueOf(2), new QuorumServer(2, new InetSocketAddress("127.0.0.1", port2 + 1000)));
+        peers.put(Long.valueOf(3), new QuorumServer(3, new InetSocketAddress("127.0.0.1", port3 + 1000)));
+
+        QuorumPeer s2 = new QuorumPeer(peers, dataDir2, dataDir2, port2, 0, 2, tickTime, initLimit, syncLimit);
+        s2.start();
+        QuorumPeer s3 = new QuorumPeer(peers, dataDir3, dataDir3, port3, 0, 3, tickTime, initLimit, syncLimit);
+        s3.start();
+        connected = false;
+        zk = new ZooKeeper("127.0.0.1:" + port2, 15000, nullWatcher);
+        while(!connected) {
+            Thread.sleep(1000);
+        }
+        for(int i = 0; i < 10; i++) {
+            zk.create("/" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+        }
+        zk.close();
+        
+        final ZooKeeper zk2 = new ZooKeeper("127.0.0.1:" + port2, 15000, nullWatcher);
+        zk2.getData("/9", false, new Stat());
+        try {
+            zk2.getData("/10", false, new Stat());
+            Assert.fail("Should have gotten an error");
+        } catch(KeeperException.NoNodeException e) {
+            // this is what we want
+        }
+        QuorumPeer s1 = new QuorumPeer(peers, dataDir1, dataDir1, port1, 0, 1, tickTime, initLimit, syncLimit);
+        s1.start();
+
+        connected = false;
+        ZooKeeper zk1 = new ZooKeeper("127.0.0.1:" + port1, 15000, nullWatcher);
+        while(!connected) {
+            Thread.sleep(1000);
+        }
+        zk1.getData("/9", false, new Stat());
+        try {
+            // /10 wont work because the session expiration
+            // will match the zxid for /10 and so we wont
+            // actually truncate the zxid for /10 creation
+            // due to an artifact of switching the xid of the standalone
+            // /11 is the last entry in the log for the xid
+            // as a result /12 is the first of the truncated znodes to check for
+            zk1.getData("/12", false, new Stat());
+            Assert.fail("Should have gotten an error");
+        } catch(KeeperException.NoNodeException e) {
+            // this is what we want
+        }
+        zk1.close();
+        QuorumBase.shutdown(s1);
+        QuorumBase.shutdown(s2);
+        QuorumBase.shutdown(s3);
+    }
+}
